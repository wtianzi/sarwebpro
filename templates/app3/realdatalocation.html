<!DOCTYPE html>
{% load static %}
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link rel="shortcut icon" href="{% static 'img/favicon.ico' %}">
  <title>SAR MAPPING DEMO</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.12/esri/themes/light/main.css"/>

  <script src="{% static 'js/d3.v4.min.js' %}"></script>
  <script src="{% static 'js/d3-polygon-clip.js' %}"></script>

  <script src="https://js.arcgis.com/4.12/"></script>
  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script src="{% static 'js/jquery.csv.js' %}"></script>
  <script src="{% static 'js/sarfunctions.js' %}"></script>
  <link rel="stylesheet" type="text/css" href="{% static 'taskgeneration.css' %}"  />
  <script type="text/javascript" src="{% static 'data/location.json' %}"></script>
  <style>
  html,
  body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }

      #sidebar {
        z-index: 99;
        position: absolute;
        top: 10%;
        left: 1%;
        height: 80%;
        background: rgba(0, 0, 0, 0.05);
        width: 80.2%;
      }

      #text {
        color: white;
        padding: 3%;
      }
      .slider {
        -webkit-appearance: none;
        width: 100%;
        height: 25px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: .2s;
        transition: opacity .2s;
      }

      table {
        font-family: arial, sans-serif;
        border-collapse: collapse;
        width: 100%;
      }

      td, th {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
      }

      tr:nth-child(even) {
        background-color: #dddddd;
      }
      .bt_save{
        padding: 8px;
        text-decoration: none;
        cursor: pointer;
        font-size: 14px;
        height: 32px;
        margin-top: 10px;
        background-color: transparent;
        border: 1px solid #0079c1;
        color: #0079c1;
        width:30%;
      }
      .bt_save_edit{
        padding: 8px;
        text-decoration: none;
        cursor: pointer;
        font-size: 14px;
        height: 32px;
        margin-top: 10px;
        border: 1px solid black;
        color: black;
        width:66%;
      }
      h3{
        margin:2px;
      }
      .sel_options{
        margin-top: 6px;
        margin-bottom: 6px;
      }
  </style>
  <script>

//https://developers.arcgis.com/javascript/latest/sample-code/sketch-geometries/index.html
//https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=sketch-update-validation
    require([
      "esri/widgets/Sketch/SketchViewModel",
      "esri/Graphic",
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/FeatureLayer",
      "esri/layers/GraphicsLayer",
      "esri/geometry/Polygon",
      "esri/geometry/geometryEngine",
      "esri/widgets/Expand",
        "esri/layers/TileLayer",
        "esri/widgets/BasemapToggle",//-----------------------------
      "esri/views/2d/draw/Draw",
      "esri/widgets/CoordinateConversion",//,      "esri/widgets/Sketch"
      "esri/widgets/DistanceMeasurement2D",
      "esri/widgets/AreaMeasurement2D",
      "esri/geometry/Extent",
      "esri/geometry/Point",
      "esri/layers/OpenStreetMapLayer",
      "esri/widgets/Track",
      "esri/widgets/Search",
      "esri/geometry/Multipoint",
      "esri/layers/ElevationLayer",
      "esri/geometry/Polyline",
      "esri/geometry/Circle",
      "esri/layers/GeoJSONLayer",
      "esri/core/promiseUtils"

    ], function(
      SketchViewModel, Graphic, Map, MapView, FeatureLayer,
      GraphicsLayer, Polygon, geometryEngine, Expand, TileLayer,BasemapToggle,
      Draw,CoordinateConversion,
      DistanceMeasurement2D,AreaMeasurement2D,Extent,Point,
      OpenStreetMapLayer,Track,Search,Multipoint,
      ElevationLayer,Polyline,Circle,GeoJSONLayer,promiseUtils
    ) {
      let view, sketchViewModel, draw,
        newDevelopmentGraphic,taskassignment_sketchViewModel,
        instructionsExpand,coordinateLayer;
      let intersects = false,
        contains = true;
      let updated_polygonring=[];
        //let graphicsLayer;
//Transportation example:
//https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=intro-layers
//Transportation service:
//https://server.arcgisonline.com/arcgis/rest/services/Reference/World_Transportation/MapServer

      let width=1600*1.5;
      let height=900*1.5;
      let m_d=new Date();
      let scale=16;//15
      let m_experimentres={
        "scenario":null,
        "lostpersontype":null,
        "traildatacenter":null,
        "participantid":null,
        "participant_index":(m_d.getMonth()+1).toString()+m_d.getDate().toString()+m_d.getHours().toString(),
        "teamnumber":5,
        "taskid":m_d.getHours().toString()+m_d.getMinutes().toString()+m_d.getSeconds().toString(),
        "taskstart":Date.now(),
        "taskstop":null,
        "taskduration":100,
        "targetcellindex":0,
        "polygonnumbers":0,
        "stophour":0,
        "visualization_type":"probability",
        "step_number":0,
        "step_details":[],//visualresponsetime: time between (the heatmap is loaded) and (active the first team icon)
        "actions":[],//#id and timestamp, {"id":"btn...","timestamp": Date.now(), "description":"click button generate task"}
        "allpolygons":null,
        "mapscale":scale,
        "totaltaskround":5 // after 5 rounds of try, the task will be complet
      };
      //36.8176602,-80.363078
      //kentlane farm (-80.572567,37.203604)
      //{" wkid":4326 }: latitude
      //
      let m_experimentaldesign ={
        "scenelist":[
          {"index":0,"scenario_index":0,"lostperson_index":0},
          {"index":1,"scenario_index":0,"lostperson_index":1},
          {"index":2,"scenario_index":0,"lostperson_index":2},
          {"index":3,"scenario_index":1,"lostperson_index":0},
          {"index":4,"scenario_index":1,"lostperson_index":1},
          {"index":5,"scenario_index":1,"lostperson_index":2},
          {"index":6,"scenario_index":2,"lostperson_index":0},
          {"index":7,"scenario_index":2,"lostperson_index":1},
          {"index":8,"scenario_index":2,"lostperson_index":2},
          {"index":9,"scenario_index":3,"lostperson_index":0},
          {"index":10,"scenario_index":3,"lostperson_index":1},
          {"index":11,"scenario_index":3,"lostperson_index":2}
        ]

      };
      let m_scenario_index=0;
      let m_lostpersontype_index=0;
      let m_scenarios=[
        {"scenario_index":0,"scenario_name":"ic1","center":[-80.4757389347337, 37.2040570285143]}, //[-80.4757389347337, 37.2040570285143]//-80.5460, 37.2041
        {"scenario_index":1,"scenario_name":"ic2","center":[-80.5450562640660, 37.1977538769385]},//[-80.5450562640660, 37.1977538769385]//-80.4757, 37.2041
        {"scenario_index":2,"scenario_name":"ic3","center":[-80.5451, 37.1978]}
      ];
      let m_lostpersontype=[
        {"lostperson_index":0,"lostperson_type":"child"},
        {"lostperson_index":1,"lostperson_type":"dementia"},
        {"lostperson_index":2,"lostperson_type":"hiker"}
      ];

      // this will be changed after the data is loaded
      let m_targetandclues={
        "target":[-80.476, 37.20],
        "clue":[{"clue_index":0,"status":"unfound","info":"cloth","data":[-80.46, 37.205],'photoid':1},
                          {"clue_index":1,"status":"unfound","info":"drink","data":[-80.47, 37.20],'photoid':2}]
      };
      let m_scenarios_rings={'child10to12':[800,1600,3200,9000],
      'dementia':[300,800,1900,8300],
      'hiker':[1100,3100,5800,18300]};

      let gcx=-80.556451;
      let gcy=37.2;

      let gwidth=10;
      let gheight=10;
      let voronoistyle="random";
      let glvertices;
      let glverticeslist=[];
      let maxdistanceerror = 0.0001;

      //acer

      let eacharea=500000;//240000;//60 acer;
      let activeWidget = null;

      let allpolygons=[];
      let allpolygons_text=[];
      let activepolygonset=[];
      let activepolygonpoints=[];
      let move_polygon;
      let area_extent;

      let timerid1,timerid2,timerid3;
      let gpspatharray={};
      let all_gpsdata={};
      let arr_featureset=[];
      let waypointstartpointarray=[];
      let gpshistoricalarraystart=[];

      let m_colorgroup={};// store color of symbols for gps and pathplaning
      let validSymbol;

      let m_filterprob=0.0000001;
      let m_lpdata_con=[];
      let m_lpdata_trajectory=[];
      let m_lpdata_tra_colormap=[];

      let m_lpdata_trial=[];
      let m_colormap=0;//0: rainbow, 1: yellow-red, 2: blue-red
      let t_rgb=[];
      let m_editing=false;
      let m_visualizationtype='byhour';// or 'byclue' if any clue is found

      let m_teamiconlocation=null;

      //let m_searchedarea=[];//all polygon marked gray
      let m_teamassign=[null,null,null,null,null];//
      let m_lptrail_pts=[];//the target person location at hour index
      let m_targetpolygon;
      let m_taskstarttime=null;
      let m_tasktrials=0;//how many time the operator tried to assign teams
      let m_taskpolygon={};

      let epsg4326_voronoiarr=[];

      const graphicInitLayer= new GraphicsLayer();
      const graphicsLayer = new GraphicsLayer({
        opacity:0.6//0.6
      });
      const gpsgraphicsLayer = new GraphicsLayer();

      const pathplanninggraphicsLayer = new GraphicsLayer({
        opacity:0.5
      });

      const gpshistoricalgraphicsLayer = new GraphicsLayer({
        opacity:0.5
      });

      const visualization_Contourmap_Layer = new GraphicsLayer({
        opacity:0.8
      });

      const visualization_Segmentheat_Layer = new GraphicsLayer({
        opacity:0.5
      });


      const visualization_Trajectories_Layer = new GraphicsLayer({
        opacity:0.5
      });

      const visualization_Cone_Layer = new GraphicsLayer({
        opacity:0.5
      });

      const teamgraphicsLayer=new GraphicsLayer({
        opacity:1.0
      });
      const graphicInteractionLayer =new GraphicsLayer();

      const temperalgraphicLayer = new GraphicsLayer();

      const graphicfilterLayer= new GraphicsLayer();

      let elevLyr = new ElevationLayer({
        // Custom elevation service
        url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer/"//"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Elevation/MtBaldy_Elevation/ImageServer"
      });

      const map = new Map({
        basemap: "hybrid",//"hybrid",//"satellite",
        //ground: "world-elevation",
        layers: [
          visualization_Contourmap_Layer,//
          visualization_Segmentheat_Layer,
          graphicsLayer,//
          gpsgraphicsLayer,//
          pathplanninggraphicsLayer,
          gpshistoricalgraphicsLayer,
          graphicInitLayer,//
          teamgraphicsLayer,//
          visualization_Trajectories_Layer,//
          graphicInteractionLayer,//
          temperalgraphicLayer,// temperal layer include target
          visualization_Cone_Layer,
          graphicfilterLayer
        ]
      });

      setUpView();

      // creates new view and map, adds featurelayers and graphicslayer to the view

      // This function is called when a user clicks on the view.
      function setUpGraphicClickHandler() {
        view.on("click", function(event) {
          //console.log("click");

          //elevation=============
          let position = event.mapPoint;
          //console.log(position);
          let queryBeforeLandslide = elevLyr.queryElevation(
            position
          );

          promiseUtils
            .eachAlways([queryBeforeLandslide])
            .then(function(results) {
              $("#elevation").text("Elenvation: "+results[0].value.geometry.z);
            });

          // check if the sketch's state active if it is then that means
          // the graphic is already being updated, no action required.
          if (sketchViewModel.state === "active") {
            //testing forbid mover
            return;
          }
          if (taskassignment_sketchViewModel.state === "active") {
            //testing forbid mover
            return;
          }

          view.hitTest(event).then(function(response) {
            let results = response.results;
            // Check if the new development graphic was clicked and pass
            // the graphic to sketchViewModel.update() with reshape tool.
            results.forEach(function(result) {
              //set the assignment: cell to team
              //result
              $("#cellname").val("S"+result.graphic.attributes.cellindex);//result.graphic.attributes.cellindex;
              if(m_editing){
                if (result.graphic.layer === sketchViewModel.layer) {
                  sketchViewModel.update([result.graphic], {
                    tool: "reshape"//"reshape"
                  });
                }
              }
              if(result.graphic.layer === taskassignment_sketchViewModel.layer){
                //console.log(taskassignment_sketchViewModel);
                //console.log("here");
                taskassignment_sketchViewModel.update([result.graphic],{
                  tool:"point"//move
                });
              }
            });
          });
        });

      }
      setUpGraphicClickHandler();

      view.when(function() {
        area_extent=view.extent;

        //drag and drop teams icon for task assignment
        taskassignment_sketchViewModel = new SketchViewModel({
          view: view,
          layer: teamgraphicsLayer,
          updatePointSymbol:{
            type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
             url: "{% static 'img/user_o_glow.png' %}",//user_glow.png
             width: "64px",
             height: "64px"
          },
          updateOnGraphicClick: false,
          defaultUpdateOptions: { // set the default options for the update operations
            toggleToolOnClick: false//false // only reshape operation will be enabled
          }
        })

        taskassignment_sketchViewModel.on(["update", "undo", "redo"], onTaskAssignmentGraphicUpdate);

        // Query all buffer features from the school buffers featurelayer

        // Create a new instance of sketchViewModel and set its required properties

        sketchViewModel = new SketchViewModel({
          view: view,
          layer: graphicsLayer,
          updateOnGraphicClick: false,
          defaultUpdateOptions: { // set the default options for the update operations
            //tool: "transform",
            toggleToolOnClick: false//false // only reshape operation will be enabled
          }
        })

        activepolygonset=[];
        // Listen to sketchViewModel's update event to do
        // graphic reshape or move validation
        sketchViewModel.on(["update", "undo", "redo"], onGraphicUpdate);
      });


      function addVoronoi(){
        let textend;
        let wholearea;
        if(activeWidget){
          textent=activeWidget.viewModel.measurement.geometry.extent;
          wholearea=activeWidget.viewModel.measurement.area;
        }
        else{
          let jsonextent=view.extent.toJSON();
          textent=Extent.fromJSON(jsonextent);
          let ori_xmin=textent.xmin;
          let ori_wid=textent.width*0.01;
          textent=textent.expand(0.8);
          let centerpoint = textent.center.clone();
          centerpoint.x= textent.center.x-(textent.xmin-ori_xmin-ori_wid);
          textent=textent.centerAt(centerpoint);
          area_extent=textent;
          wholearea=geometryEngine.planarArea(Polygon.fromExtent(textent));
        }
        let npoints=2*Math.round(wholearea/eacharea+0.5);      //wholearea=wholetask.area;//metric   240  : acre  60
        let lbx=textent.xmin,
            lby=textent.ymin,
            rtx=textent.xmax,
            rty=textent.ymax;
            gwidth=textent.width;
            gheight=textent.height;

        let sites = d3.range(npoints)//15
                   .map(function(d) { return [Math.random() * gwidth+lbx, Math.random() * gheight+lby]; });
        let in_point=new Point({
          x:textent.center.x+ 0.1*(Math.random()-0.5)*textent.width,
          y:textent.center.y+ 0.1*(Math.random()-0.5)*textent.height,
          spatialReference:view.spatialReference
        });
        //sites = GetSitesFromN(npoints,in_point,textent);
        sites = GetSites(npoints,textent);
        let voronoi = d3.voronoi().extent([[lbx,lby], [rtx,rty]]);
        let diagram = voronoi(sites),
            links = diagram.links(),
            vpolygons = diagram.polygons();


        if(activeWidget){
          //console.log(activeWidget);
          vpolygons=ClipPolygongsByPoints(vpolygons,activeWidget.viewModel.measurement.geometry.rings[0].slice(0,activeWidget.viewModel.measurement.geometry.rings[0].length-1));
        }
        //console.log(vpolygons);
        //download("voronoiori.txt",JSON.stringify(vpolygons));
        ClearAll();
        addGraphics(vpolygons);
      }

      function ClipPolygongsByPoints(vpolygons,points){
        let cpy=[];
        for(let i=0;i<vpolygons.length;i++){
          let temp=d3.polygonClip(vpolygons[i],polygonClone(points.reverse()));
          if(temp.length>0){ cpy.push(temp); }
        }
        return cpy;
      }
      function GetSites(n,t_extent){
        let res_points=[];
        //center point [0,0]
        //first round radius:1, second:2,third:3
        let t_radius=1;
        let t_firstround=6;

        //second round
        let res_count=0;
        let t_wholearea=0;
        let t_cellarea=t_radius*t_radius/t_firstround;

        while(n>res_count){
          let t_roundarea=t_radius*t_radius-t_wholearea;
          let t_celldegree=t_cellarea/t_roundarea;
          let t_totaldegree=0;
          while(t_totaldegree<=0.99){
            res_points.push([(t_radius-0.5)*Math.sin(2*Math.PI*t_totaldegree),(t_radius-0.5)*Math.cos(2*Math.PI*t_totaldegree)]);
            t_totaldegree=t_totaldegree+t_celldegree;
            res_count=res_count+1;
          }
          t_wholearea=t_radius*t_radius;
          t_radius=t_radius+1;
        }

        //standrized from 1:1 into width and height ratio
        t_radius=t_radius-1;
        let t_wscale=t_extent.width/(2*t_radius);
        let t_hscale=t_extent.height/(2*t_radius);

        for(let i=0;i<res_count;i++){
          res_points[i][0]=res_points[i][0]*t_wscale+t_extent.center.x;
          res_points[i][1]=res_points[i][1]*t_hscale+t_extent.center.y;
        }
        return res_points;
      }
      function GetSitesFromN(n,in_point,t_extent){
        let t_portion=gwidth/gheight;
        //n points
        let res_points=[];
        let t_poly=Polygon.fromExtent(t_extent);
        //in_point=t_poly.centroid;
        //calculate the shortiest distance from edge to
        //----pass
        //get the nearest point on t_poly from in_point
        let res_nearst=0.5*Math.min(t_extent.width,t_extent.height);
        //let res_nearst=geometryEngine.nearestVertex(t_poly,in_point,"meters").distance;
        //nearestpoint.coordinate;
        //nearestpoint.distance;
        res_i=[];
        for (let i=4;i<9;i++){
          let j=0, m=0;
          while(m<=n){
            m=m+i*Math.pow(2,j);
            j=j+1;
          }
          let t_x=n+i*2^j-m;
          if(t_x<2 && j>1){
            res_i.push([j-1,i,i*2^(j-1)+1]);
          }
          else{
            res_i.push([j,i,t_x]);//[j circles, m-n the outer ring number]
          }
        }
        let t_arr=res_i.pop();
        while(t_arr[0]<=1 && res_i.length>0){
          t_arr=res_i.pop();
        }
        let t_root=0;
        let arr_root=[];
        for(let i=0;i<t_arr[0];i++){
          t_root+=Math.pow(2,i);
          arr_root.push(t_root);
        }
        let r=res_nearst/Math.sqrt(t_root);
        // r, a, r+a
        let t_area=Math.pow(r,2);// the area of central circle
        let s_area=0;
        let t_pre_r=0;
        let ncount=0;
        for (let i=0;i<t_arr[0]-1;i++){
          s_area=t_area*arr_root[i];
          let t_ra=Math.sqrt(s_area);//
          //draw points
          let t_r=0.5*(t_ra+t_pre_r);//t_portion*t_pre_r
          let k=2*Math.PI/(t_arr[1]*Math.pow(2,i)); // radin of each circle
          for(let j=0;j<t_arr[1]*Math.pow(2,i);j++){
            res_points.push([in_point.x+t_portion*t_r*Math.cos(j*k),in_point.y+t_r*Math.sin(j*k)]);
            ncount+=1;
          }
          t_pre_r=t_ra;
        }
        let t_ra=res_nearst;
        //draw points
        let t_r=0.5*(t_ra+t_pre_r);
        let k=2*Math.PI/(t_arr[2]);
        for(let j=0;j<t_arr[2];j++){
          res_points.push([in_point.x+t_portion*t_r*Math.cos(j*k),in_point.y+t_r*Math.sin(j*k)]);
          ncount+=1;
        }
        if(0){
          res_points=d3.range(n)//15
                     .map(function(d) { return [Math.random() * t_extent.width+t_extent.xmin, Math.random() * t_extent.height+t_extent.ymin]; });
        }
        return res_points;
      }

      function addTriangle(){

      }

      function addFreedraw(){
        let action = draw.create("polygon");
        // focus the view to activate keyboard shortcuts for drawing polygons
        view.focus();

        // listen polygonDrawAction events to give immediate visual feedback
        // to users as the polygon is being drawn on the view.
        action.on("vertex-add", drawPolygon);
        action.on("cursor-update", drawPolygon);
        action.on("vertex-remove", drawPolygon);
        action.on("redo", drawPolygon);
        action.on("undo", drawPolygon);
        action.on("draw-complete", drawPolygon);
      }

      function addGraphics(vtriangles) {
        // transfer the voronoi polygon:vpolygons to gispolygon
        //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);
        let text_symbol = {
          type: "text",  // autocasts as new TextSymbol()
          color: "white",
          haloColor: "black",
          haloSize: "1px",
          text: "You are here",
          xoffset: 3,
          yoffset: 3,
          font: {  // autocast as new Font()
            size: 12,
            family: "sans-serif",
            weight: "bold"
          }
        };
        for (let i=0;i<vtriangles.length;i++){
          vtriangles[i].push(vtriangles[i][0]);
          let polygon = createGeometry(vtriangles[i]);
          let newDevelopmentGraphic = new Graphic({
            geometry: polygon,
            symbol: validSymbol,
            attributes: {
              newDevelopment: "new store",
              cellindex:(i+1).toString(),
              polygonindex:i.toString()
            }
          });
          text_symbol.text="S"+(i+1).toString();
          let t_point=new Graphic ({
            geometry:newDevelopmentGraphic.geometry.centroid,
            symbol:text_symbol
          });
          allpolygons.push(newDevelopmentGraphic);
          allpolygons_text.push(t_point);
        }
        updated_polygonring=vtriangles;

        graphicsLayer.addMany(allpolygons);
        graphicsLayer.addMany(allpolygons_text);
      }

      function getGPSDisplayUpdate(pointcolor=[0,0,0],linecolor=[0,0,0]){
        gpsgraphicsLayer.removeAll();
        //random a color
        //draw all gpsdata
        for (const key in gpspatharray){
          //Testing
          //console.log(gpspatharray[key]);
          let pt_arr=gpspatharray[key];
          let in_point=new Point({
                  latitude:pt_arr[pt_arr.length-1][1],//lat,
                  longitude:pt_arr[pt_arr.length-1][0],//long,
                  spatialReference:view.spatialReference
                });
          let t_graphic1=  new Graphic({
            geometry: in_point,
            symbol:  {
                 type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                 style:"circle",
                 color: pointcolor,//[getRandomInt(255), getRandomInt(255), getRandomInt(255)],//[t_mag, 0,0],
                 size:20
               }
          });
          gpsgraphicsLayer.add(t_graphic1);

          // First create a line geometry (this is the Keystone pipeline)
          let polyline = {
            type: "polyline", // autocasts as new Polyline()
            paths: gpspatharray[key]//  [[-80.582342,37.199622],[-80.581031,37.204559],[-80.577359,37.207806]]//[[-111.3, 52.68], [-98, 49.5], [-93.94, 29.89]]
          };
          // Create a symbol for drawing the line
          let lineSymbol = {
            type: "simple-line", // autocasts as SimpleLineSymbol()
            color: linecolor,//[getRandomInt(255), getRandomInt(255), getRandomInt(255)],
            width: 2
          };
          // Create an object for storing attributes related to the line
          let lineAtt = {
            Name: "GPS "+document.getElementById('sel_gpsdevice').options[key].text,
            Owner: "SAR",
            Length: "..."
          };
          let polylineGraphic = new Graphic({
            geometry: polyline,
            symbol: lineSymbol,
            attributes: lineAtt
          });
          gpsgraphicsLayer.add(polylineGraphic);
        }
      }

      function createGeometry(vertices) {
        return new Polygon({
          rings: vertices,
          //spatialReference: {wkid: 102100 }
          spatialReference: view.spatialReference
        });
      }

      function createSymbol(color, style, width, outlineColor) {
        return {
          type: "simple-fill",
          style: style,
          color: color,
          outline: {
            color: outlineColor,
            width: width
          }
        }
      }

      // Create new view, map and layers... set up the view
      function setUpView() {
        coordinateLayer=new FeatureLayer({
          //wkid:4326
          //spatialReference: { wkid: 4326  }
          spatialReference: { wkid: 102100  }
        });
        let transportationLayer = new TileLayer({
          url: "https://server.arcgisonline.com/arcgis/rest/services/Reference/World_Transportation/MapServer",
          // This property can be used to uniquely identify the layer
          id: "something",
          visible: true
        });
        //map.add(transportationLayer);
        let riverLayer = new FeatureLayer({
          url:
          "https://services8.arcgis.com/ZXMBUOxDBbivoAgJ/arcgis/rest/services/RiverMiles/FeatureServer"
          // This property can be used to uniquely identify the layer
        });
        //map.add(riverLayer);
        //console.log(riverLayer.gdbVersion);
        view = new MapView({
          container: "viewDiv",
          map: map,
          zoom: scale,
          center: m_scenarios[m_scenario_index].center//[gcx,gcy],//,35.4
        });
        m_experimentres["scenario"]=m_scenarios[m_scenario_index];
        m_experimentres["lostpersontype"]=m_lostpersontype[m_lostpersontype_index];

        let toggle = new BasemapToggle({
          // 2 - Set properties
          view: view, // view that provides access to the map's 'topo' basemap
          nextBasemap: "topo" // allows for toggling to the 'hybrid' basemap
        });
        // Add widget to the top right corner of the view
        view.ui.add(toggle, "bottom-left");
        //add track widget
        let trackWidget = new Track({
          view: view
        });
        view.ui.add(trackWidget, "top-left");
        // Adds the search widget below other elements in
        // the top left corner of the view
        let searchWidget = new Search({
          view: view
        });
        view.ui.add(searchWidget, {
          position: "bottom-right",
          index: 5
        });
        setupEditing();
        //view.ui.add("draw-polygon", "top-left");
        draw = new Draw({
        view: view
        });
        //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);//task generation
        validSymbol = createSymbol([212,221,222, 0.2], "solid", 2, [255,255, 255]);//task generation


        m_colorgroup = ColorGroupInitialize();
      }

      document.getElementById("btntaskassignment").onclick=function() {
        m_tasktrials=m_tasktrials+1;
        m_experimentres["step_number"]=m_tasktrials;
        let i_hr=document.getElementById("myRange").value;
        //console.log(m_tasktrials);

        m_experimentres["actions"].push({"id":"btntaskassignment","timestamp": Date.now(), "description":"click task assign", 'trial':m_tasktrials,'hourslide':i_hr});

        //console.log(m_experimentres);
        //save to the database
        AddTeams();

        let t_stoptime=Date.now();
        //console.log(m_teamassign);
        let team_detail=[];
        for (let i =0; i<m_teamassign.length;i++){
          if (m_teamassign[i]){
            team_detail.push({"team_index":i,"cellindex":m_teamassign[i].attributes.cellindex,"polygonindex":m_teamassign[i].attributes.polygonindex});
          }
          else{
            team_detail.push({"team_index":i,"cellindex":null,"polygonindex":null});
          }
        }

        m_experimentres["step_details"].push({
          "step_index":m_experimentres["step_details"].length+1,
          "team_cell":team_detail,//m_teamassign,
          "starttime":m_taskstarttime,
          "stoptime":t_stoptime,
          "duration":t_stoptime-m_taskstarttime
        });


        for(let i=0;i<m_teamassign.length;i++){
          //console.log(m_teamassign[i]);
          if(m_teamassign[i]){
            //check if the clue are in the assigned area
            //console.log(m_targetandclues);
            for(let j=0;j<m_targetandclues.clue.length;j++){

              let t_pt=new Point({
                latitude: m_targetandclues.clue[j].data[1],
                longitude: m_targetandclues.clue[j].data[0],
                spatialReference: view.spatialReference
              });
              if(geometryEngine.contains(m_teamassign[i].geometry,t_pt)){
                m_visualizationtype='byclue';

                let t_clueobj;
                let URL = "{% url 'getcluemedia' %}";
                let data = {
                 csrfmiddlewaretoken: '{{ csrf_token }}',
                 'photoid': m_targetandclues.clue[j].photoid.toString()
                };
                $.post(URL, data, function(response){
                  t_clueobj=JSON.parse(response);
                  if(t_clueobj.flag == 'success'){
                     DrawClueToInitLayer(t_pt,t_clueobj,[0, 102, 255, 0.8]);
                  }
                  else{ alert(response); }
                });
                // change the clue status from "unfound" to "show"
                m_targetandclues.clue[j].status="show";
                let t_contour_value=0;
                if(m_targetandclues.clue[0].status=="show" && m_targetandclues.clue[1].status=="show"){
                  t_contour_value=3;
                }
                else if(m_targetandclues.clue[0].status=="show"){
                  t_contour_value=2;
                }
                else if(m_targetandclues.clue[1].status=="show"){
                  t_contour_value=1;
                }
                document.getElementById("myClues").value=t_contour_value;
                $("#lmyClues").text("Clue(0-3): "+t_contour_value);
                UpdateVisualization();
              }
            }

            //check if the target is in the array
            if(m_teamassign[i].attributes.cellindex==m_targetpolygon.attributes.cellindex){
              //display the targetarea
              DrawPolygonToInitLayer(m_targetpolygon,"red");
              DrawcongratulationsToInitLayer();

              //name:unixtime_participantid_taskid
              let filename=m_experimentres["participant_index"]+"_"+Date.now().toString();
              m_experimentres["taskstop"]=Date.now();
              m_experimentres["taskduration"]=m_experimentres["taskstop"]-m_experimentres["taskstart"];
              //download(filename+".txt",JSON.stringify(m_experimentres));
              m_tasktrials=0;
            }
            else{
              DrawPolygonToInitLayer(m_teamassign[i]);
            }
          }
        }
        if(m_tasktrials==m_experimentres.totaltaskround){
          //
          DrawCompletTaskToInitLayer();
          let filename=m_experimentres["participant_index"]+"_"+Date.now().toString();
          m_experimentres["taskstop"]=Date.now();
          m_experimentres["taskduration"]=m_experimentres["taskstop"]-m_experimentres["taskstart"];
          //download(filename+".txt",JSON.stringify(m_experimentres));
          m_tasktrials=0;
        }

        //After five times, the experiment stops.

        m_teamassign=[null,null,null,null,null];
        m_taskstarttime=null;
        i_hr+=2;
      }



      function DrawcongratulationsToInitLayer(){
        let graphic = new Graphic({
          geometry: area_extent.center,//view.extent.center,
          symbol: {
            type: "text",
            color: [255,125,0],
            haloColor: "black",
            haloSize: "2px",
            text: "Congratulations!",
            xoffset: 3,
            yoffset: 50,
            font: { // autocast as Font
              size: 100,
              family: "sans-serif"
            }
          }
        });
        graphicInitLayer.add(graphic);

        graphic = new Graphic({
          geometry: area_extent.center,//view.extent.center,
          symbol: {
            type: "text",
            color: [255,125,0],
            haloColor: "black",
            haloSize: "2px",
            text: "Target is found: S"+m_targetpolygon.attributes.cellindex.toString(),
            xoffset: 3,
            yoffset: 0,
            font: { // autocast as Font
              size: 50,
              family: "sans-serif"
            }
          }
        });
        graphicInitLayer.add(graphic);

      }
      function DrawCompletTaskToInitLayer(){
        let graphic = new Graphic({
          geometry: area_extent.center,//view.extent.center,
          symbol: {
            type: "text",
            color: [255,125,0],
            haloColor: "black",
            haloSize: "2px",
            text: "This round is finished,",
            xoffset: 0,
            yoffset: 60,
            font: { // autocast as Font
              size: 50,
              family: "sans-serif"
            }
          }
        });
        graphicInitLayer.add(graphic);
        graphic = new Graphic({
          geometry: area_extent.center,//view.extent.center,
          symbol: {
            type: "text",
            color: [255,125,0],
            haloColor: "black",
            haloSize: "2px",
            text: "please start a new search.",
            xoffset: 0,
            yoffset: 0,
            font: { // autocast as Font
              size: 50,
              family: "sans-serif"
            }
          }
        });
        graphicInitLayer.add(graphic);
      }
      function DrawPolygonToInitLayer(t_obj,t_color=[0, 102, 255, 0.8]){
        //draw the polygon into graphicInitLayer
        let graphic = new Graphic({
          geometry: t_obj.geometry,
          symbol: {
            type: "simple-fill", // autocasts as SimpleFillSymbol
            color: t_color,//[0, 102, 255, 0.8],//[178, 102, 234, 0.1],
            style: "backward-diagonal"
          }
        });

        graphicInitLayer.add(graphic);

      }

      // DrawClueToInitLayer
      function DrawClueToInitLayer(t_pt,t_clueobj,t_color=[0, 102, 255, 0.8]){
        let graphic = new Graphic({
          geometry: t_pt,
          symbol:  {
            type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
            url: "{% static 'img/clue2.png' %}",//user.png
            width: "32px",
            height: "32px"
            /*
               type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
               style:"circle",
               color: t_color,
               size: 40
               */
             },
          popupTemplate:{
              title: "Clue_"+t_clueobj.cluephotoid+", ("+ t_clueobj.lon +","+t_clueobj.lat+")",
              content:[{
                type: "media",
                mediaInfos: [{
                  title: t_clueobj.name,
                  type: "image",
                  caption: t_clueobj.detail,
                  value: {sourceURL: t_clueobj.url}
                }]
              }]
          } //end of popupTemplate
        });
        graphicInitLayer.add(graphic);
        //temperalgraphicLayer.add(graphic);
      }


      document.getElementById("btndisplaytarget").onclick=function() {
        DrawToTemperalGraphicLayer(m_targetandclues.target,type="point");
        m_experimentres["actions"].push({"id":"btndisplaytarget","timestamp": Date.now(), "description":"click dislpay"});

      }
      document.getElementById("btneditcells").onclick=function() {

        if(m_editing){
          document.getElementById("btneditcells").value="Edit cells (Stop)";
          m_experimentres["actions"].push({"id":"btneditcells","timestamp": Date.now(), "description":"Edit cells stops"});
          m_editing=false;
        }
        else{
          document.getElementById("btneditcells").value="Edit cells (Editing)";
          m_editing=true;
          m_experimentres["actions"].push({"id":"btneditcells","timestamp": Date.now(), "description":"Edit cells start"});
        }


      }
        //generate voronoi
      document.getElementById("btngeneratearea").onclick=function() {
        m_experimentres["actions"].push({"id":"btngeneratearea","timestamp": Date.now(), "description":"generate task"});
        graphicsLayer.removeAll();
        view.graphics.removeAll();
        gpsgraphicsLayer.removeAll();
        pathplanninggraphicsLayer.removeAll();
        gpshistoricalgraphicsLayer.removeAll();

        m_tasktrials=0;
        epsg4326_voronoiarr=[];
        //wholetask=activeWidget.viewModel.measurement;
        allpolygons=[];
        allpolygons_text=[];
        glverticeslist=[];
        if(voronoistyle=="random"){
          addVoronoi();
          //view.complete();
        }
        else if(voronoistyle=="triangle"){
          addTriangle();
          //view.complete();
        }
        else if(voronoistyle=="clear"){
          addFreedraw();
        }

        AddTeams(true);
        DisplayLostPersonInfo();

        //m_experimentres["allpolygons"]=allpolygons;
        m_experimentres["polygonnumbers"]=allpolygons.length;
        //load target and calculate their regions.
        //m_targetpolygon=allpolygons[getRandomInt(allpolygons.length)];
        SetTargetpolygon();
        if(m_targetpolygon){
          m_experimentres["targetcellindex"]=m_targetpolygon.attributes.cellindex;
        }

        m_experimentres["scenario"]=m_scenarios[m_scenario_index];
        m_experimentres["lostpersontype"]=m_lostpersontype[m_lostpersontype_index];

        DrawAllPoints();
      };

      // target data is in the m_targetandclues object
      // function updated after the clue updates v2.1
      function SetTargetpolygon(){
        //console.log(m_targetandclues);
        let t_pt=new Point({
          latitude: m_targetandclues.target[1],
          longitude: m_targetandclues.target[0],
          spatialReference: view.spatialReference
        });
        //console.log(t_pt);
        //console.log(allpolygons);
        //console.log(t_pt);
        //console.log(allpolygons);
        for(let i=0;i<allpolygons.length;i++){
          if(geometryEngine.contains(allpolygons[i].geometry,t_pt)){
            m_targetpolygon=allpolygons[i];
            break;
          }
        }
      }

      function SetTargetpolygon_hourlychanged(){
        let rank=parseInt(document.getElementById("sel_rank").value);
        let arr_trial=m_lpdata_trial.filter(obj=>{ return obj.rank === rank;});
        let arr_data=arr_trial[0]['data'];
        m_lptrail_pts=[];
        let t_start=0;
        let m_interval=600; // 600: 1 hour, 10: 1 mins,
        if (arr_data.length>300){
          t_start=600;
        }
        for (let i = t_start; i < arr_data.length;i+=600){
          m_lptrail_pts.push([arr_trial[0]['data'][i][0],arr_trial[0]['data'][i][1]]);
        }
        m_experimentres["traildatacenter"]=m_lptrail_pts;
        let i_hr=document.getElementById("myRange").value;

        if (i_hr>=m_lptrail_pts.length){
          i_hr=m_lptrail_pts.length-1;
        }
        let t_pt=new Point({
          latitude: m_lptrail_pts[i_hr][1],
          longitude: m_lptrail_pts[i_hr][0],
          spatialReference: view.spatialReference
        });
        //console.log(t_pt);
        //console.log(allpolygons);
        for(let i=0;i<allpolygons.length;i++){
          if(geometryEngine.contains(allpolygons[i].geometry,t_pt)){
            m_targetpolygon=allpolygons[i];
            break;
          }
        }
      }

      // this function is called from the polygon draw action events
      // to provide a visual feedback to users as they are drawing a polygon
      function drawPolygon(event) {
        if(voronoistyle!="clear" && voronoistyle!="sidebar") return;
        let glvertices = event.vertices;
        //remove existing graphic
        view.graphics.removeAll();
        if(glverticeslist.length>0) addGraphics(glverticeslist);
        // create a new polygon
        let polygon = new Polygon({
          rings: glvertices,
          spatialReference: view.spatialReference
        });
        // create a new graphic representing the polygon, add it to the view
        //taskgeneration
        let graphic = new Graphic({
          geometry: polygon,
          symbol: {
            type: "simple-fill", // autocasts as SimpleFillSymbol
            color: [178, 102, 234, 0.8],//[178, 102, 234, 0.1],
            style: "solid",
            outline: { // autocasts as SimpleLineSymbol
              color: [255, 255, 255],
              width: 2
            }
          }
        });
        view.graphics.add(graphic);
        // calculate the area of the polygon
        let area = geometryEngine.geodesicArea(polygon, "acres");
        if (area < 0) {
          // simplify the polygon if needed and calculate the area again
          let simplifiedPolygon = geometryEngine.simplify(polygon);
          if (simplifiedPolygon) {
            area = geometryEngine.geodesicArea(simplifiedPolygon, "acres");
          }
        }
        // start displaying the area of the polygon
        labelAreas(polygon, area);
        if(event.type=="draw-complete"){
          addGraphics(glvertices);
          if( voronoistyle=="clear"){
            glverticeslist.push(glvertices);
            //addFreedraw();
          }
        }
      }

      //Label polyon with its area
      function labelAreas(geom, area) {
        let graphic = new Graphic({
          geometry: geom.centroid,
          symbol: {
            type: "text",
            color: "white",
            haloColor: "black",
            haloSize: "1px",
            text: area.toFixed(2) + " acres",
            xoffset: 3,
            yoffset: 3,
            font: { // autocast as Font
              size: 14,
              family: "sans-serif"
            }
          }
        });
        view.graphics.add(graphic);
      }

      function setupEditing() {
        // input boxes for the attribute editing
        editArea = document.getElementById("editArea");
        // Listen to the feature form's submit event.
        // Expand widget for the editArea div.
        const editExpand = new Expand({
          expandIconClass: "esri-icon-edit",
          expandTooltip: "Expand Edit",
          expanded: true,
          view: view,
          content: editArea
        });
        view.ui.add(editExpand, "top-right");
      }

      let ccWidget = new CoordinateConversion({
        view: view
        //container: "coordinatesdiv"
      });
      view.ui.add(ccWidget, "bottom-left");
      //view.ui.add(ccWidget,document.getElementById("coordinatesdiv"));
//-----------------adding new functions here---------------------

      function onGraphicUpdate(event){
        let mover,temppolyset,t_pointIndex,orignalmover;//for reshape
        let t_pt_array;//for move

        //if(event.toolEventInfo != null){
        //console.log(event.toolEventInfo.mover.geometry.x +","+ event.toolEventInfo.mover.geometry.y+":"+ event.toolEventInfo.type );
        //}
        //if is the first active or not
        if (event.state=="active"){
          let graphic = event.graphics[0];
          //console.log(event);
          let t_status=0;//1: "reshape", 2: "move";
          mover=event.toolEventInfo.mover.geometry;
          //console.log(event.toolEventInfo.mover);


          if(event.toolEventInfo.type=="reshape-start"){
            t_status=1;
            t_pointIndex=event.toolEventInfo.mover.attributes.pointIndex;
            orignalmover=graphic.geometry.rings[0][t_pointIndex];

            temppolyset=[];
            activepolygonpoints=[];
            //selected=event.toolEventInfo.selected[0].geometry;
            for(let i=0;i<allpolygons.length;i++){
              if(geometryEngine.equals(allpolygons[i].geometry,graphic.geometry)){
                temppolyset.push(allpolygons[i]);
                continue;
              }
              if(geometryEngine.touches(mover,allpolygons[i].geometry)){
                //array, start end with the two nearby points
                //let array_points=GetPolygonPoints(mover.x,mover.y,allpolygons[i].geometry.rings[0]);
                let array_points=GetPolygonPoints(orignalmover[0],orignalmover[1],allpolygons[i].geometry.rings[0]);

                activepolygonpoints.push(array_points);
                //console.log("mover"+mover.x+","+mover.y);
                //console.log("original"+orignalmover[0]+","+orignalmover[1]);
                //console.log(activepolygonset);
                activepolygonset.push(allpolygons[i]);
              }
              else{
                temppolyset.push(allpolygons[i]);
              }
            }
            allpolygons=temppolyset;
          }
          else if(event.toolEventInfo.type=="reshape"){
            t_status=1;
          }
          else if(event.toolEventInfo.type=="reshape-stop"){

            allpolygons=allpolygons.concat(activepolygonset);
            activepolygonset=[];
            t_status=1;
          }
          else if(event.toolEventInfo.type=="move-start"){
            temppolyset=[];
            activepolygonpoints=[];
            //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);
            t_status=2;
            for(let i=0;i<allpolygons.length;i++){
              if(geometryEngine.equals(allpolygons[i].geometry,graphic.geometry)){
                move_polygon = new Graphic({
                  geometry: allpolygons[i].geometry,
                  symbol: validSymbol,
                  attributes: {
                    newDevelopment: "new store",
                    cellindex: allpolygons[i].attributes.cellindex,
                    polygonindex: allpolygons.length
                  }
                });
                activepolygonset.push(allpolygons[i]);
                continue;
              }
              temppolyset.push(allpolygons[i]);
            }
            allpolygons=temppolyset;
          }
          else if(event.toolEventInfo.type=="move"){
            t_status=2;
          }
          else if(event.toolEventInfo.type=="move-stop"){
            t_status=2;
            allpolygons.push(move_polygon);
            //console.log(allpolygons);
            graphicsLayer.removeMany(activepolygonset);
            graphicsLayer.addMany([move_polygon]);

            activepolygonset=[];
          }
          //renew the polygons
          if(activepolygonset.length>0 && t_status==1){

            graphicsLayer.removeMany(activepolygonset);
            activepolygonset=GeneratePolygonBasedonPoints(mover.x,mover.y,activepolygonpoints);
            graphicsLayer.addMany(activepolygonset);

          }

        }
      }
      function onTaskAssignmentGraphicUpdate(event){
        let graphic = event.graphics[0];
        //console.log("onTaskAssignmentGraphicUpdate");
        //console.log(graphic);
        //Teamindex

        //detect the overlap area
        if (event.state=="active"){
          mover=event.toolEventInfo.mover.geometry;
          if(event.toolEventInfo.type=="move-start"){
            if(m_taskstarttime ==null){
              m_taskstarttime=Date.now();
            }

          }
          else if(event.toolEventInfo.type=="move"){


          }
          else if(event.toolEventInfo.type=="move-stop"){
            //console.log(mover);
            //console.log(graphic);
            for(let i=0;i<allpolygons.length;i++){

              if(geometryEngine.contains(allpolygons[i].geometry,mover)){
                //document.getElementById(graphic.attributes.htmlid).text("S"+allpolygons[i].attributes.cellindex.toString());
                //console.log(mover);
                $(graphic.attributes.htmlid).text("S"+allpolygons[i].attributes.cellindex.toString());
                m_teamassign[graphic.attributes.Teamindex-1]=allpolygons[i];
                break;
              }

            }

          }
        }

      }

      //tpoly is an array[[,],[,]]
      function GetPolygonPoints(x,y,tpoly){
        //break the ring

        let t_array=[];
        let i=0;
        let pointofline=0;//0: not on line, 1: vertices, 2: center, 3: on the line
        for(i=0;i<tpoly.length-1;i++){
          if((Math.abs(tpoly[i][0]-x)< maxdistanceerror) && (Math.abs(tpoly[i][1]-y)< maxdistanceerror )){
            pointofline=1;
            break;
          }
        }
        if( pointofline===1 ){
          //console.log("points as vertices");
          //poins as vertices of the line
          t_array=t_array.concat(tpoly.slice(i+1,tpoly.length-1),tpoly.slice(0,i));
          //console.log(t_array);
          return t_array;
        }

        for(i=0;i<tpoly.length-1;i++){
          if( ( Math.abs(0.5*( tpoly[i][0]+tpoly[i+1][0] )-x )< maxdistanceerror)
                && ( Math.abs(0.5*( tpoly[i][1]+tpoly[i+1][1] )-y) < maxdistanceerror) ){
                    pointofline=2;
                    break;
          }
        }
        if (pointofline===2){

          //have problem need debug
          t_array=t_array.concat(tpoly.slice(i+1,tpoly.length-1),tpoly.slice(0,i+1));
        }
        else{
          //poins on the line
          //add more pass

          t_array=null;
        }
        return t_array;
      }

      function GetPolygonPoints_Vertices(x,y,tpoly){
        //break the ring
        let t_array=[];
        for(let i=0;i<tpoly.length-1;i++){
          if((Math.abs(tpoly[i][0]-x)< maxdistanceerror) && (Math.abs(tpoly[i][1]-y)< maxdistanceerror )){
            pointofline=1;
            t_array=t_array.concat(tpoly.slice(i+1,tpoly.length-1),tpoly.slice(0,i));
            return t_array;
          }
        }
        return tpoly;
      }

      //update new polygon
      function GeneratePolygonBasedonPoints(x,y,array_points){
        let tmppolysets=[];

        //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);

        if(array_points.length==0){
          return tmppolysets;
        }
        for(let i=0;i<array_points.length;i++){
          entry=array_points[i];

          let vertices=[];
          vertices=vertices.concat([[x,y]],entry,[[x,y]]);
          //console.log(vertices);
          //console.log("-------------");
          let polygon = createGeometry(vertices);
          newDevelopmentGraphic = new Graphic({
            geometry: polygon,
            symbol: validSymbol,
            attributes: {
              newDevelopment: "new store"
            }
          });
          tmppolysets.push(newDevelopmentGraphic);
        }

        return tmppolysets;
      }

      function PointsMerge(points_array,maxd){
        //ring with no points repeated

        resarray=[];
        while(points_array.length>0){
          entry=points_array.pop();
          //console.log(entry);
          //console.log("point merge");
          let i=0;
          for(i = 0;i<points_array.length;i++){
            if(Math.abs(points_array[i][0]-entry[0]< maxd) && Math.abs(points_array[i][1]-entry[1])< maxd ){
              break;
            }
          }
          if(i<points_array.length){
            continue;
          }
          else{
            resarray.push(entry);
          }
        }
        return resarray;
      }
//-----------------------------------------------------
      document.getElementById("distanceButton").addEventListener("click",
             function () {
               setActiveWidget(null);
               if (!this.classList.contains('active')) {
                 setActiveWidget('distance');
               } else {
                 setActiveButton(null);
               }
               m_experimentres["actions"].push({"id":"distanceButton","timestamp": Date.now(), "description":"generate task"});
             });

      document.getElementById("areaButton").addEventListener("click",
       function () {
         setActiveWidget(null);
         if (!this.classList.contains('active')) {
           setActiveWidget('area');
         } else {
           setActiveButton(null);
         }
       });

      function setActiveWidget(type) {
       switch (type) {
         case "distance":
           activeWidget = new DistanceMeasurement2D({
             view: view
           });

           // skip the initial 'new measurement' button
           activeWidget.viewModel.newMeasurement();
           activeWidget.

           view.ui.add(activeWidget, "bottom-right");
           setActiveButton(document.getElementById('distanceButton'));
           break;
         case "area":
           activeWidget = new AreaMeasurement2D({
             view: view
           });

           // skip the initial 'new measurement' button
           activeWidget.viewModel.newMeasurement();

           view.ui.add(activeWidget, "bottom-right");
           //console.log(activeWidget);
           setActiveButton(document.getElementById('areaButton'));
           break;
         case null:
           if (activeWidget) {
             view.ui.remove(activeWidget);
             activeWidget.destroy();
             activeWidget = null;
           }
           break;
       }
      }

      function setActiveButton(selectedButton) {
         // focus the view to activate keyboard shortcuts for sketching
         view.focus();
         let elements = document.getElementsByClassName("active");
         for (let i = 0; i < elements.length; i++) {
           elements[i].classList.remove("active");
         }
         if (selectedButton) {
           selectedButton.classList.add("active");
         }
       }

      document.getElementById("clearall").addEventListener("click",
       function () {
         m_experimentres["actions"].push({"id":"clearall","timestamp": Date.now(), "description":"clearall"});
         m_lpdata_con=[];
         m_lpdata_trial=[];
         m_lpdata_trajectory=[];
         m_lpdata_tra_colormap=[];

         ClearAll();
         area_extent=view.extent;
       });

       function ClearAll(){
         allpolygons=[];
         allpolygons_text=[];
         activepolygonset=[];
         activepolygonpoints=[];
         glverticeslist=[];
         updated_polygonring=[];
         m_taskstarttime=null;
         m_visualizationtype='byhour';

         // change clue status from 'show' to 'unfound'
         for (let j=0;j<m_targetandclues.clue.length;j++){
           m_targetandclues.clue[j].status='unfound';
         }
         //area_extent=view.extent;
         graphicsLayer.removeAll();
         view.graphics.removeAll();
         gpsgraphicsLayer.removeAll();
         pathplanninggraphicsLayer.removeAll();
         gpshistoricalgraphicsLayer.removeAll();
         graphicInitLayer.removeAll();
         teamgraphicsLayer.removeAll();
         visualization_Contourmap_Layer.removeAll();
         visualization_Trajectories_Layer.removeAll();
         visualization_Cone_Layer.removeAll();
         temperalgraphicLayer.removeAll();
         visualization_Segmentheat_Layer.removeAll();

         setActiveWidget(null);
         sketchViewModel.complete();
         //taskassignment_sketchViewModel.complete();
         view.ui.remove(activeWidget);
         //activeWidget.destroy();
         activeWidget = null;
       }

       function PolyArrayToJson(polyarray)
       {
         if(polyarray.length<1){
           return "";
         }
         res_json={};
         for (let i=0;i<polyarray.length;i++){
           res_json[i]=polyarray[i];
         }
         return JSON.stringify(res_json);
       }

       document.getElementById("savetasks").addEventListener("click",
         function () {
           m_experimentres["actions"].push({"id":"savetasks","timestamp": Date.now(), "description":"savetasks"});

           let t_tasknotes=document.getElementById("tasknotes").value;
           t_tasknotes=t_tasknotes.split(' ').join('_');
           if(false){
             //task_all
             alert("Please try another task name.");
             //console.log(document.getElementById("tasknotes").value+" is already exist, please enter another one!");
           }
           else {
             let URL = "{% url 'tasksave' %}";
             let dbpolystr=PolyArrayToJson(updated_polygonring);
             let data = {
                     csrfmiddlewaretoken: '{{ csrf_token }}',
                     'task_notes': t_tasknotes,
                     'task_id': t_tasknotes,
                     'Taskarea': updated_polygonring.length.toString(),
                     'task_polygon': dbpolystr
                    };
             $.post(URL, data, function(response){
               let res=JSON.parse(response);

                 if(res.flag == 'success'){
                   //console.log(res.Taskarea);
                   //add date and task number and a random number
                   //task name:
                   let task_url="{% url 'taskgenerationform' %}"+"/"+t_tasknotes+'_'+'0/';
                   //console.log(task_url);
                   //let win = window.open("{% url 'taskgenerationform' %}", '_blank');
                   let win = window.open(task_url, '_blank');
                   win.focus();
                   //open a new tab for task TaskGeneration

                  }
                 else{ alert(response); }
             });
           }
         });
         function LoadLPFromCSV_Tra_Item(t_url,t_rank=0,t_index=0){
           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 m_lpdata_trajectory.push({'index':t_index,'notes':'clue','clue':t_index,'data':t_data});

              }
            });
            return true;
         }
         function LoadLPFromCSV_Tra_All(t_url,t_rank=0,t_index=0){

           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 // column: time by hour, lon,lat,index of trajectory
                 // cut t_data into 2 dimentional array every 13 items [ [t_data[1],t_data[2]],[],..,[] ]

                 let all_obj={};
                 let sizeoftrajectory=100;
                 let startpoint=1;
                 //initialize all_obj
                 for (let i=startpoint;i<sizeoftrajectory+1;i++){
                   let t_obj={};
                   all_obj[i]=t_obj;
                 }
                 // clean the data
                for(let i=0;i<t_data.length;i++){
                  all_obj[t_data[i][3]][t_data[i][0]]=[t_data[i][1],t_data[i][2]];
                }

                // trans obj to arr
                let res_arr=[];
                for(let i=0;i<=GetObjectLength(all_obj);i++){
                  if (i in all_obj){
                    res_arr.push(Object.values(all_obj[i]));
                  }

                }
                //console.log(res_arr);

                 m_lpdata_trajectory.push({'index':-1,'notes':'all','data':res_arr});

                 m_colormap=document.getElementById("sel_colormap").selectedIndex;
                 let t_color_arr=[];
                 let t_ratio=1.0/sizeoftrajectory;

                 for (let j=0;j<sizeoftrajectory;j++){
                   t_rgb=hslToRgb(1-t_ratio*j, 1, 1-0.6*t_ratio*j);//rainbow
                   t_color_arr.push(t_rgb);
                   //t_color_arr.push([getRandomInt(255), getRandomInt(255), getRandomInt(255)]);
                 }
                 m_lpdata_tra_colormap.push(t_color_arr);

                 t_color_arr=[];
                 for (let j=0;j<sizeoftrajectory;j++){
                   let t_rgb=hslToRgb(0.2*(1-t_ratio*j), 1, 1-t_ratio*j);
                   t_color_arr.push(t_rgb);
                   //t_color_arr.push([255-255*t_ratio*j,0,0]);
                 }
                 m_lpdata_tra_colormap.push(t_color_arr);
                 t_color_arr=[];
                 for (let j=0;j<sizeoftrajectory;j++){
                  let t_rgb=hslToRgb(0.6, 1, 1-0.5*t_ratio*j);
                  t_color_arr.push(t_rgb);
                }
                m_lpdata_tra_colormap.push(t_color_arr);
              }
            });
            return true;
         }

         function LoadLPFromCSV_trial(t_url,t_rank=0,t_index=0){
           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 m_lpdata_trial.push({'index':t_index,'rank':t_rank,'data':t_data});
                 //console.log(m_lpdata_trial);
              }
            });
            return true;
         }

         // Loading contour map
         function LoadLPFromCSV_con(t_url,t_arr_count,t_hour=0,t_rank=0,t_type='byhour'){
           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 m_lpdata_con.push({'type':t_type,'hour':t_hour,'rank':t_rank,'data':t_data});

                 if (m_lpdata_con.length == t_arr_count){

                   document.getElementById("loadlpmcsv").value="Load LPM Data (Loaded)";
                   m_experimentres["actions"].push({"id":"loadlpmcsv","timestamp": Date.now(), "description":"loaded"});

                   SetTargetClues();
                 }
              }
            });
            return true;
         }

         function AddTeams(init=false,teamcount=5){
           teamgraphicsLayer.removeAll();
           if(init){
             m_teamiconlocation=null;
           }
           //team 1,2,3,4,5
           if (m_teamiconlocation){
             for(let i=0;i<m_teamiconlocation.length;i++){
               $(m_teamiconlocation[i].attributes.htmlid).text("SX");
             }

           }
           else{
             m_teamiconlocation=[];
             let t_y=0.95*view.extent.ymax+0.05*view.extent.ymin;
             let t_start=0.2*view.extent.xmax+0.8*view.extent.xmin;
             let t_stop=0.5*view.extent.xmax+0.5*view.extent.xmin;
             let t_steps=(t_stop-t_start)/teamcount;
             for(let i=0;i<teamcount;i++){
               //console.log(view);
               let in_point=new Point({
                 x:t_start+i*t_steps,
                 y:t_y,
                 spatialReference:view.spatialReference
               });

               let t_graphic =  new Graphic({
                 geometry: in_point,
                 symbol:  {
                   type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
                    url: "{% static 'img/user_o.png' %}",//user.png
                    width: "64px",
                    height: "64px"
                  },
                  attributes:{
                    Name:"Team",
                    Teamindex:i+1,
                    Status:"Assigned",
                    htmlid:"#th_team"+(i+1).toString()
                  }
                });
                m_teamiconlocation.push(t_graphic);
                $(t_graphic.attributes.htmlid).text("SX");
             }
           }
           teamgraphicsLayer.addMany(m_teamiconlocation);
           /*
           for(let j=0;j<teamgraphicsLayer.graphics.length;j++){
             taskassignment_sketchViewModel.update([teamgraphicsLayer.graphics.items[j]],{
               tool:"move"//move
             });
           }*/
         }


         function AddCluetoInteractionImagelayer(){
           graphicInteractionLayer.removeAll();
           //display all clue points
           arr_featureset=[];
           for (let i=0;i<m_targetandclues.clue.length;i++){
             if(m_targetandclues.clue[i].status=="show"){
               let in_point=new Point({
                 longitude:m_targetandclues.clue[i].data[0],
                 latitude:m_targetandclues.clue[i].data[1],
                 spatialReference:view.spatialReference
               });
               let t_graphic =  new Graphic({
                 geometry: in_point,
                 symbol:  {
                      type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                      style:"circle",
                      color: [255,0,0],
                      size: 40
                    },
                  attributes:{
                    Name:"Clue",
                    Rank:1
                  }
               });
               arr_featureset.push(t_graphic);
             }
           }
           graphicInteractionLayer.addMany(arr_featureset);
           graphicInteractionLayer.visible=true;
         }

         // this function has delay
         function getClueImageByPhotoid(photoid){
           let URL = "{% url 'getcluemedia' %}";
           let data = {
                   csrfmiddlewaretoken: '{{ csrf_token }}',
                   'photoid': photoid.toString()
                  };
           $.post(URL, data, function(response){
             let res=JSON.parse(response);
               if(res.flag == 'success'){
                 //console.log(res);
                }
               else{ alert(response); }
           });
         }
         function DrawToTemperalGraphicLayer(obj,type){
           temperalgraphicLayer.removeAll();
           // ajax load image from database aka ClueMedia

           // lost person target position
           if(type==="point"){
             // draw obj to temperalgraphicLayer
             let in_point=new Point({
                     latitude:obj[1],//lat,
                     longitude:obj[0],//long,
                     spatialReference:view.spatialReference
                   });
             let t_graphic1=  new Graphic({
               geometry: in_point,
               symbol:  {
                    type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                    style:"circle",
                    color: [getRandomInt(255), getRandomInt(255), getRandomInt(255)],//[t_mag, 0,0],
                    size:20
                  },
                attributes:{
                  Name:"Target",
                  Hour:0,
                  Rank:1
                }
             });
             temperalgraphicLayer.add(t_graphic1);

             let t_clue=m_targetandclues;


             for (let i=0;i<m_targetandclues.clue.length;i++){
               let in_point=new Point({
                 longitude:m_targetandclues.clue[i].data[0],
                 latitude:m_targetandclues.clue[i].data[1],
                 spatialReference:view.spatialReference
               });

               let t_clueobj;

               let URL = "{% url 'getcluemedia' %}";
               let data = {
                 csrfmiddlewaretoken: '{{ csrf_token }}',
                 'photoid': m_targetandclues.clue[i].photoid.toString()
               };
               $.post(URL, data, function(response){
                 t_clueobj=JSON.parse(response);
                 if(t_clueobj.flag == 'success'){

                   let t_graphic =  new Graphic({
                     geometry: in_point,
                     symbol:  {
                       type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
                       url: "{% static 'img/clue2.png' %}",//user.png
                       width: "32px",
                       height: "32px"
                       /*
                          type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                          style:"square",
                          color: [255,0,0],
                          size: 40
                          */
                        },
                      attributes:{
                        Name:"Clue",
                        Hour:0,
                        Rank:1
                      },
                      popupTemplate:{
                          title: "Clue_"+t_clueobj.cluephotoid+", ("+ t_clueobj.lon +","+t_clueobj.lat+")",
                          content:[{
                            type: "media",
                            mediaInfos: [{
                              title: t_clueobj.name,
                              type: "image",
                              caption: t_clueobj.detail,
                              value: {
                                sourceURL: t_clueobj.url
                              }
                            }]
                          }
                        ]
                      }
                   });
                   temperalgraphicLayer.add(t_graphic);
                  }
                 else{ alert(response); }
               });


             }
           }

           temperalgraphicLayer.visible=true;
         }
         function GetConePoints(center,clue,diameter,angle=0.1) {
           let y=clue[1]-center[1];
           let x=clue[0]-center[0];
           //console.log(Math.sqrt(x*x+y*y));
           let i_angle=angle*Math.PI;
           let t_angle=0;
           if(x==0){
             if(y>0){
                t_angle=0.5*Math.PI;
             }
             else{
               t_angle=-0.5*Math.PI;
             }
           }
           else{
             t_angle=Math.atan(y/x);
           }

           let left=t_angle+i_angle;
           let right=t_angle-i_angle;
           let lpt,rpt;
           if (x>0){
             lpt=[diameter*Math.cos(left)+center[0] , diameter*Math.sin(left)+center[1]];
             rpt=[diameter*Math.cos(right)+center[0] , diameter*Math.sin(right)+center[1]];
           }
           else{
             //console.log([x,Math.PI,t_angle,i_angle]);

             left=-t_angle+i_angle;
             right=-t_angle-i_angle;

             lpt=[center[0]-diameter*Math.cos(left), diameter*Math.sin(left)+center[1]];
             rpt=[center[0]-diameter*Math.cos(right) , diameter*Math.sin(right)+center[1]];
           }
           return [lpt,center,rpt];
         }

         function AddLPDataToTrajectorylayer(t_type = "byhour"){
           let i_hr=parseInt(document.getElementById("myRange").value);
           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           let clueindex=0;
           let t_arr=m_lpdata_trajectory.filter(obj=>{ return obj.index === -1;});
           let t_data=t_arr[0].data;

           if (t_type == "byclue"){
             clueindex=parseInt(document.getElementById("myClues").value);
             //console.log(clueindex);
             if(clueindex<4){
               let t_reduced_arr=[];
               // trajectory: 0: all, 1: clue 1, 2:clue2,3:clue1,2
               // contourmap: 0: clue1, 1: clue2, 2: clue1,2, 3: all
               let t_reduced_index_arr=m_lpdata_trajectory.filter(obj=>{ return obj.index === clueindex;});

               for(let i=0;i<t_reduced_index_arr[0].data.length;i++){
                 //console.log(t_data[t_reduced_index_arr[0].data[i]-1]);
                 t_reduced_arr.push(t_data[t_reduced_index_arr[0].data[i]-1]);
               }
               //console.log(t_reduced_arr);
               t_data=t_reduced_arr;
               //console.log(t_data);
             }
             else{
               clueindex=0;
             }
           }
           else if(t_type == "byhour"){
             clueindex=0;
           }
           visualization_Trajectories_Layer.removeAll();
           //console.log(t_data);

           // display all 100 trajectories
           // filter m_lpdata_trial
           let arr_visual=[];

           let t_case = document.getElementById("displaytype").checked;  // default unchecked: bypath, checked: byhour

           if(t_case){ //byhour
             let mid_data=[];//13 items

             for (let j=0;j<12;j++){
               mid_data.push([]);
             }
             for(let i=0;i<t_data.length;i++){
               for (let j=1;j< t_data[i].length;j++){
                 mid_data[j-1].push([ [t_data[i][j][0],t_data[i][j][1]],[t_data[i][j-1][0],t_data[i][j-1][1]] ]);
                 // color map

               }
             }
             //t_data=mid_data;
             //console.log(m_lpdata_tra_colormap);
             for(let i=0;i<mid_data.length;i++){
               let polyline = {
                   type:'polyline',
                  paths: mid_data[i],
                  spatialReference: { wkid: 4326 }
                };
                let polylineGraphic=new Graphic({
                  geometry: polyline,
                  symbol:{
                          type: "simple-line", // autocasts as new SimpleLineSymbol()
                          color: m_lpdata_tra_colormap[m_colormap][(11-i)*9], // RGB color values as an array
                          width: 1
                        }
                });
                                //console.log(polylineGraphic);
                arr_visual.push(polylineGraphic);
             }
             for(let i=0;i<mid_data[i_hr].length;i++){
               let t_color= m_lpdata_tra_colormap[m_colormap][(11-i_hr)*9];
               if (i_hr>=t_data.length){
                 i_hr=t_data.length-1;
                 t_color=[125,125,125,0.1];
               }
               else if( i_hr >0){
                 // compare
                 if(mid_data[i_hr][i][0][1]==mid_data[i_hr][i][1][1] && mid_data[i_hr][i][0][0]==mid_data[i_hr][i][1][0])
                 {
                   t_color=[125,125,125,0.1];
                 }

               }
               let t_pt={
                 type:'point',
                 latitude: mid_data[i_hr][i][0][1],
                 longitude: mid_data[i_hr][i][0][0]
               }
               let t_ptgraphic =  new Graphic({
                 geometry: t_pt,
                 symbol:  {
                      type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                      style:"circle",
                      color: t_color,// t_color,//[t_mag, 0,0],
                      size: 10
                    }
               });
               arr_visual.push(t_ptgraphic);
             }

           }
           else{
             //console.log(t_data);
             for(let i=0;i<t_data.length;i++){

               let polyline = {
                   type:'polyline',
                  paths: t_data[i],
                  spatialReference: { wkid: 4326 }
                };
                let polylineGraphic=new Graphic({
                  geometry: polyline,
                  symbol:{
                          type: "simple-line", // autocasts as new SimpleLineSymbol()
                          color: m_lpdata_tra_colormap[m_colormap][i], // RGB color values as an array
                          width: 1
                        }
                });
                //console.log(polylineGraphic);
                arr_visual.push(polylineGraphic);
             }
             for(let i=0;i<t_data.length;i++){
               let t_color=m_lpdata_tra_colormap[m_colormap][i];
               if (i_hr>=t_data.length){
                 i_hr=t_data.length-1;
                 t_color=[125,125,125,0.1];
               }
               else if( i_hr >0){

                 if(t_data[i][i_hr]!=null && t_data[i][i_hr-1]!=null){
                   if(t_data[i][i_hr][0]==t_data[i][i_hr-1][0] && t_data[i][i_hr][1]==t_data[i][i_hr-1][1]){
                     t_color=[125,125,125,0.1];
                   }
                 }
               }
               if(t_data[i][i_hr]!=null){
                 let t_pt={
                   type:'point',
                   latitude: t_data[i][i_hr][1],
                   longitude: t_data[i][i_hr][0]
                 }
                 let t_ptgraphic =  new Graphic({
                   geometry: t_pt,
                   symbol:  {
                        type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                        style:"circle",
                        color: t_color,//[t_mag, 0,0],
                        size: 10
                      }
                 });
                 arr_visual.push(t_ptgraphic);
               }

             }
           }

           visualization_Trajectories_Layer.addMany(arr_visual);
           visualization_Trajectories_Layer.visible=true;
         }

         function AddLPDataToConelayer(){

           visualization_Cone_Layer.removeAll();
           let angle=0.1; // 0~180, 0~1

           arr_featureset=[];
           //let t_clueindex=document.getElementById("myClues").value;

           for (let i=0;i<m_targetandclues.clue.length;i++){

             if(m_targetandclues.clue[i].status=="show"){

               let pt=m_targetandclues.clue[i].data;
               let initpt = m_scenarios[m_scenario_index].center;//[lat,log]

               // calculate a Cone
               // start -> ipp -> end
               let persontype=document.getElementById("sel_lpm").value;
               //1100  0.0083 : 100  0.000755
               let arr_start_init_end=GetConePoints(initpt,pt,0.0000076*m_scenarios_rings[persontype][1],angle);
               //console.log(arr_start_init_end);
               let paths=[];
               //paths.push(pt);
               //paths.push(initpt);
               paths.push(arr_start_init_end[0]);
               paths.push(arr_start_init_end[1]);
               paths.push(arr_start_init_end[2]);

               // draw the Cone

               let polyline = new Polyline({
                hasZ: false,
                hasM: true,
                paths: [paths],
                spatialReference: { wkid: 4326 }
              });
                let polylineGraphic=new Graphic({
                geometry: polyline,
                symbol:{
                        type: "simple-line", // autocasts as new SimpleLineSymbol()
                        color: [255,255,0], // RGB color values as an array
                        width: 1
                      }
              });
              //console.log(polylineGraphic);
              arr_featureset.push(polylineGraphic);
             }
           }
           visualization_Cone_Layer.addMany(arr_featureset);
           visualization_Cone_Layer.visible=true;
         }

         function AddLPDataToSegmentheatlayer(t_type = "byhour"){
           visualization_Segmentheat_Layer.removeAll();
           contourring_arr=[]
           arr_featureset=[];
           if(m_lpdata_con == null){
             return;
           }

           let t_data_con,t_hour;

           if (t_type == "byclue"){
             t_hour=document.getElementById("myClues").value;
           }
           else if(t_type == "byhour"){
             t_hour=document.getElementById("myRange").value;
           }

           let t_rank=parseInt(document.getElementById("sel_rank").value)-1;
           arr_heatpoints=[];

           let t_break=m_lpdata_con.length;
           let i=0;
           while(i<t_break){
             if(m_lpdata_con[i]['type']==t_type){
               if(m_lpdata_con[i]['hour']==t_hour && m_lpdata_con[i]['rank']==t_rank){
                 arr_heatpoints=m_lpdata_con[i]['data'];
                 break;
               }
             }
             i++;
           }

           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           //loop to find rings
           let t_rings=[];//
           let all_paths=[];
           let t_startprobability=arr_heatpoints[0][0];

           let col3 = arr_heatpoints.map(function(value,index) { return value[0]; });
           let t_min = Math.min(...col3);
           let t_max=Math.max(...col3);
           let t_range=t_max-t_min;

           let t_mag=(t_startprobability-t_min)/t_range;

           let t_distance=0.0001;//define as a circle
           let t_len=0;
           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           arr_heatpoints.map(function(item){
             t_len=t_rings.length-1;
             if(item[0]==t_startprobability){
               if(t_len>3){
                 if(t_distance<((item[1]-t_rings[t_len][0])*(item[1]-t_rings[t_len][0])+ (item[2]-t_rings[t_len][1])*(item[2]-t_rings[t_len][1]))){
                   t_rings.push(t_rings[0]);
                   contourring_arr.push(t_rings);
                   t_rings=[];
                 }
               }
             }
             else{
               t_rings.push(t_rings[0]);
               contourring_arr.push(t_rings);
               t_rings=[];
               t_startprobability=item[0];
               t_mag=(t_startprobability-t_min)/t_range;
             }
             t_rings.push(item.slice(1));
           });
           if(t_rings.length>0){
             t_rings.push(t_rings[0]);
             contourring_arr.push(t_rings);
             t_rings=[];
           }
           // send contourring_arr to back for process

           let voronoiarr=[];
           let markspatialreference="epsg3857";
           if(epsg4326_voronoiarr.length>1){
             markspatialreference="epsg4326";
             voronoiarr=epsg4326_voronoiarr;
           }
           else{
             markspatialreference="epsg3857";
             for(i=0;i<allpolygons.length;i++){
               voronoiarr.push(allpolygons[i].geometry.rings[0]);
             }
           }

           //console.log(voronoiarr);
           //console.log(contourring_arr);

           let URL = "{% url 'getsegmentVal' %}";
           let data = {
             csrfmiddlewaretoken: '{{ csrf_token }}',
             'contourarr': JSON.stringify(contourring_arr),
             'voronoiarr': JSON.stringify(voronoiarr),
             'spatialReference': markspatialreference
           };
           $.post(URL, data, function(response){
             t_obj=JSON.parse(response);
             if(t_obj.flag == 'success'){
               //console.log(t_obj);
               let colorarr=t_obj.segmentval;
               let updatevoronoiarr=t_obj.updatevoronoi;
               if (updatevoronoiarr.length>0){
                 epsg4326_voronoiarr=updatevoronoiarr;
               }

               for(let j=0;j<allpolygons.length;j++){
                 let polygonGraphic = new Graphic({
                   geometry: allpolygons[j].geometry,
                   symbol: {
                           type: "simple-fill",
                           color: [0, 0, 255,colorarr[j]/150],//[0, 0, colorarr[j]*0.5+125,colorarr[j]/255],
                           outline: {
                             style:"none"
                           }
                         }
                 });
                 //console.log(colorarr[j]);
                 arr_featureset.push(polygonGraphic);//t_graphic

               }
               //console.log(arr_featureset);
               visualization_Segmentheat_Layer.addMany(arr_featureset);
               visualization_Segmentheat_Layer.visible=true;
              }
             else{ alert(response); }
           });


         }

         function AddLPDataToContourlayer(t_type = "byhour"){
           visualization_Contourmap_Layer.removeAll();
           arr_featureset=[];
           if(m_lpdata_con == null){
             return;
           }
           //console.log(m_lpdata_con);

           let t_data_con,t_hour;

           if (t_type == "byclue"){
             t_hour=document.getElementById("myClues").value;
           }
           else if(t_type == "byhour"){
             t_hour=document.getElementById("myRange").value;
           }
           //console.log(m_lpdata_con);


           let t_rank=parseInt(document.getElementById("sel_rank").value)-1;
           arr_heatpoints=[];

           let t_break=m_lpdata_con.length;
           let i=0;
           while(i<t_break){
             if(m_lpdata_con[i]['type']==t_type){
               if(m_lpdata_con[i]['hour']==t_hour && m_lpdata_con[i]['rank']==t_rank){
                 arr_heatpoints=m_lpdata_con[i]['data'];
                 //console.log(m_lpdata_con[i]);
                 break;
               }
             }
             i++;
           }
           //console.log(arr_heatpoints);

           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           //loop to find rings
           let t_rings=[];//
           let all_paths=[];
           let t_startprobability=arr_heatpoints[0][0];

           let col3 = arr_heatpoints.map(function(value,index) { return value[0]; });
           let t_min = Math.min(...col3);
           let t_max=Math.max(...col3);
           let t_range=t_max-t_min;

           let t_mag=(t_startprobability-t_min)/t_range;

           let markerSymbol = {
             type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
             color: [226, 119, 40],
             outline: {
               style:"none"
             }
           };
          let fillSymbol= {
            type: "simple-fill", // autocasts as SimpleFillSymbol
            color: [226, 119, 40],
            outline: { // autocasts as SimpleLineSymbol

              style:"none"
            }
          };
          let t_distance=0.0001;//define as a circle
          let t_len=0;
          let t_index=0;
          let t_oppacity=3;//0.8
          m_colormap=document.getElementById("sel_colormap").selectedIndex;
           arr_heatpoints.map(function(item){
             t_len=t_rings.length-1;
             if(item[0]==t_startprobability){
               if(t_len>3){
                 if(t_distance<((item[1]-t_rings[t_len][0])*(item[1]-t_rings[t_len][0])+ (item[2]-t_rings[t_len][1])*(item[2]-t_rings[t_len][1]))){
                   //console.log((item[1]-t_rings[0][0])*(item[1]-t_rings[0][0])+ (item[2]-t_rings[0][1])*(item[2]-t_rings[0][1]));
                   // if two points are two far away, define them as different circles
                   t_rings.push(t_rings[0]);
                   let tmulpt=new Polygon({
                      rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                      spatialReference: { wkid: 4326 }
                    });
                    if (m_colormap==0){
                      t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
                    }
                    else if (m_colormap==1){
                      t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
                    }
                    else{
                      t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
                    }
                    t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

                    fillSymbol.color=t_rgb;
                    let polylineGraphic = new Graphic({
                      geometry: tmulpt, // Add the geometry created in step 4
                      symbol: fillSymbol
                    });
                     arr_featureset.push(polylineGraphic);//t_graphic

                     //ContourRingdownload(t_rings,t_index);
                     t_index=t_index+1;

                   t_rings=[];
                 }
               }
             }
             else{
               //ori:t_rings.push(t_rings[t_rings.length-1]);
               t_rings.push(t_rings[0]);
               //console.log(t_rings);

               let tmulpt=new Polygon({
                  rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                  spatialReference: { wkid: 4326 }
                });
                if (m_colormap==0){
                  t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
                }
                else if (m_colormap==1){
                  t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
                }
                else{
                  t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
                }
                t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

                fillSymbol.color=t_rgb;
                let polylineGraphic = new Graphic({
                  geometry: tmulpt, // Add the geometry created in step 4
                  symbol: fillSymbol
                });
                 arr_featureset.push(polylineGraphic);//t_graphic

                 //ContourRingdownload(t_rings,t_index);
                 t_index=t_index+1;

                 t_rings=[];
                 t_startprobability=item[0];
                 t_mag=(t_startprobability-t_min)/t_range;
             }
             t_rings.push(item.slice(1));
           });
           if(t_rings.length>0){

             //ori:t_rings.push(t_rings[t_rings.length-1]);
             t_rings.push(t_rings[0]);
             //console.log(t_rings);

             let tmulpt=new Polygon({
                rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                spatialReference: { wkid: 4326 }
              });
              if (m_colormap==0){
                t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
              }
              else if (m_colormap==1){
                t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
              }
              else{
                t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
              }
              t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

              fillSymbol.color=t_rgb;
              let polylineGraphic = new Graphic({
                geometry: tmulpt, // Add the geometry created in step 4
                symbol: fillSymbol
              });
               arr_featureset.push(polylineGraphic);//t_graphic

               //ContourRingdownload(t_rings,t_index);
               t_index=t_index+1;

               t_rings=[];
           }
           //console.log(arr_featureset);
           visualization_Contourmap_Layer.addMany(arr_featureset);
           visualization_Contourmap_Layer.visible=true;

         }

         document.getElementById("lpinfo").onclick=function() {
           DisplayLostPersonInfo();
           m_experimentres["actions"].push({"id":"lpinfo","timestamp": Date.now(), "description":"display lost person information"});
         }

         function SetTargetClues(){
           // need m_lpdata_trajectory
           let t_plitphase=0.618;
           let t_targetarr=m_lpdata_trajectory.filter(obj=>{ return obj.index === -1;});

           //let tdata_len=t_targetarr[0].data.length;
           //let tlen=Math.floor(t_targetarr[0].data[tdata_len-2].length * t_plitphase);
           //console.log(tdata_len,tlen);

           // pick two point from t_targetarr
           let t_cluearr=m_lpdata_trajectory.filter(obj=>{ return obj.index === 3;});
           let tcluedata_len=t_cluearr[0].data.length;

           let tlen_target=0;
           let tlen_clue=tcluedata_len-1;
           //let tlen_clue2=Math.floor(tcluedata_len * t_plitphase);

           let index_tar=Math.floor(t_targetarr[0].data[tlen_target].length * t_plitphase);
           if(index_tar==0 || index_tar==4){
             index_tar==3;
           }
           let index_clue1=0;
           let index_clue2=4;

           m_targetandclues={
             "target":t_targetarr[0].data[tlen_target][index_tar],
             "clue":[{"clue_index":0,"status":"unfound","info":"cloth","data":t_targetarr[0].data[tlen_clue][index_clue1],'photoid':1},
                    {"clue_index":1,"status":"unfound","info":"drink","data":t_targetarr[0].data[tlen_clue][index_clue2],'photoid':2}]
            };
            //console.log(tcluedata_len,"target",tlen_target,index_tar,"clues:",tlen_clue,index_clue1,index_clue2,m_targetandclues)
            //console.log(tlen_clue1,tlen_clue2,index_clue1,index_clue2);

         }

         function DisplayLostPersonInfo(){
           graphicInitLayer.removeAll();
           let t_feature=[];

           let t_center=new Point({
             longitude:m_scenarios[m_scenario_index].center[0],
             latitude:m_scenarios[m_scenario_index].center[1],
             spatialReference:view.spatialReference
           });//m_scenarios[m_scenario_index].center;

           let t_graphic =  new Graphic({
             geometry: t_center,//area_extent.center,//view.extent.center,
             symbol:  {
                  type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                  style:"triangle",
                  color: [255,0,0],//[t_mag, 0,0],
                  size:10
                },
              attributes:{
                Name:"Last known position",
                LostHour:2,
                Type:"hiker"
              },
              popupTemplate:{
                  title: "{Name}",
                  content: [
                    {
                      type: "fields",
                      fieldInfos: [{fieldName: "Name"},{fieldName: "LostHour"},{fieldName: "Type"}]
                    }
                  ]
              }
           });
           t_feature.push(t_graphic);

            //draw 25%,50%,75% ring
           let rings_arr=[1100,3100,5800,18300];
           let persontype=document.getElementById("sel_lpm").value;//lpm_hiker
           rings_arr=m_scenarios_rings[persontype];
           let ringsname_arr=["25% ring","50% ring","75% ring","95% ring"];
           for(let i=0;i<4;i++){
             let t_circle=new Circle({
               center:t_center,//area_extent.center,
               radius:rings_arr[i]
             });
             t_graphic =  new Graphic({
               geometry: t_circle,//view.extent.center,
               symbol:  {
                    type: "simple-fill", // autocasts as new SimpleMarkerSymbol()
                    style:"none",
                    outline:{
                      color:[255,i*50,0,0.6-0.4*i/4],
                      width:2
                    }
                  },
                attributes:{
                  Name:ringsname_arr[i],
                  LostHour:2,
                  Type:"hiker"
                }
             });

             t_feature.push(t_graphic);
            }
            // draw team rectangle
            //from x: 0.05-0.6
            //from y: 0.1 - 0.3
            let t_rect=new Polygon({
              rings:[
                [0.85*view.extent.xmin+0.15*view.extent.xmax,0.02*view.extent.ymin+0.98*view.extent.ymax],
                [0.5*view.extent.xmin+0.5*view.extent.xmax,0.02*view.extent.ymin+0.98*view.extent.ymax],
                [0.5*view.extent.xmin+0.5*view.extent.xmax,0.08*view.extent.ymin+0.92*view.extent.ymax],
                [0.85*view.extent.xmin+0.15*view.extent.xmax,0.08*view.extent.ymin+0.92*view.extent.ymax],
                [0.85*view.extent.xmin+0.15*view.extent.xmax,0.02*view.extent.ymin+0.98*view.extent.ymax],
              ],
              spatialReference:view.spatialReference
            });

            t_graphic =  new Graphic({
              geometry: t_rect,//view.extent.center,
              symbol:  {
                   type: "simple-fill", // autocasts as new SimpleMarkerSymbol()
                   style:"none",
                   outline:{
                     color:[255,125,0,1],
                     width:2
                   }
                 },
               attributes:{
                 Name:"team group"
               }
            });
            //t_feature.push(t_graphic);

            let t_point=new Point({
              x:0.9*view.extent.xmin+0.1*view.extent.xmax,
              y:0.07*view.extent.ymin+0.93*view.extent.ymax,
              spatialReference:view.spatialReference
            });
            t_graphic=new Graphic ({
              geometry:t_point,
              symbol:{
                type: "text",  // autocasts as new TextSymbol()
                color: [255,125,0],//"white",
                haloColor: "black",
                haloSize: "1px",
                text: "Teams: ",
                xoffset: 3,
                yoffset: 3,
                font: {  // autocast as new Font()
                  size: 50,
                  family: "sans-serif",
                  weight: "bold"
                }
              }
            });
            t_feature.push(t_graphic);
            //draw the polygon into graphicInitLayer
            //console.log(m_searchedarea);

           graphicInitLayer.addMany(t_feature);
         }

          document.getElementById("gotoGPSLocation").onclick=function(){
            view.goTo(gpspatharray[document.getElementById("sel_gpsdevice").selectedIndex]);
          }
          document.getElementById("gotoGPSLocation2").onclick=function(){
            view.goTo(gpspatharray[document.getElementById("sel_gpsdevice2").selectedIndex]);
          }
          document.getElementById("gotoGPSLocation3").onclick=function(){
            view.goTo(waypointstartpointarray);
          }

          document.getElementById("gotoGPSLocation4").onclick=function(){
            view.goTo(gpshistoricalarraystart);
          }

         document.getElementById("loadlpmcsv").onclick=function() {
           if(document.getElementById("loadlpmcsv").value=="Load LPM Data (Loaded)"){
             //clear everything before loading anything

           }
           //draw initial condition centerpoints
           m_experimentres["actions"].push({"id":"loadlpmcsv","timestamp": Date.now(), "description":"start loading"});

           document.getElementById("lpmmodeldisplay").disabled=true;
           document.getElementById("loadlpmcsv").value="Load LPM Data (Loading)";

          let persontype=document.getElementById("sel_lpm").value;//lpm_hiker
          // time duration
          let ih_start = 1;//1
          let ih_stop = 12;//12;

          // number of clue files
          let count_clues=4;

          // number of contour map files
          let totalfiles=1*(ih_stop-ih_start+1)+count_clues;

          //folder of files
          let lpmfolder="/static/data/LPMdata5/"+m_scenarios[m_scenario_index]["scenario_name"]+"/"+persontype;//"LPMdata3"
          //console.log(lpmfolder);
          //load 2 types of data: contour map, trajectory
          for(let i=ih_start;i<=ih_stop;i++){
            for(let t_rank=1;t_rank<=1;t_rank++){
              // m_lpdata_con.push
              let csvfilename=lpmfolder+"/best fits/contour data csv/con_"+persontype+"bf"+t_rank.toString()+"_t"+i.toString()+".csv";
              LoadLPFromCSV_con(csvfilename,totalfiles,i-1,t_rank-1,'byhour');
            }
          }

          // clue1:t1, clue2:t2, clue12:t3, final: t4, final is the overall
          let cluenames=['final','clue1','clue2','clue12'];
          for(let i=0;i<count_clues;i++){
            let csvfilename= lpmfolder+"/clues/contour data csv/con_"+persontype+"_bf1_"+cluenames[i]+".csv";
            LoadLPFromCSV_con(csvfilename,totalfiles,i,0,'byclue');
            //console.log(csvfilename);
          }
          let csvfilename= lpmfolder+"/clues/traj_"+persontype+"_bf1.csv";
          LoadLPFromCSV_Tra_All(csvfilename,0,0);

          for(let i=0;i<count_clues;i++){
            let csvfilename= lpmfolder+"/clues/"+cluenames[i]+"index_"+persontype+"_bf1.csv";
            LoadLPFromCSV_Tra_Item(csvfilename,0,i);
            //console.log(csvfilename);
          }


          document.getElementById("lpmmodeldisplay").disabled=false;
         }

         document.getElementById("sel_lpm").onchange=function(){

           m_lpdata_con=[];
           m_lpdata_trial=[];
           m_lpdata_trajectory=[];
           m_lpdata_tra_colormap=[];

           ClearAll();
           document.getElementById("loadlpmcsv").value="Load LPM Data";
           DisableAllGraphicLayers();
           m_lostpersontype_index=document.getElementById("sel_lpm").selectedIndex;


         }
         document.getElementById("sel_rank").onchange=function(){

             m_experimentres["visualization_type"]=document.getElementById("sel_lpmodel").value;
             m_experimentres["actions"].push({"id":"sel_lpmodel","timestamp": Date.now(), "description":m_experimentres["visualization_type"]});
             DisableAllGraphicLayers();
             UpdateVisualization();
         }

          document.getElementById("sel_lpmodel").onchange=function(){

            m_experimentres["visualization_type"]=document.getElementById("sel_lpmodel").value;
            m_experimentres["actions"].push({"id":"sel_lpmodel","timestamp": Date.now(), "description":m_experimentres["visualization_type"]});
            DisableAllGraphicLayers();
            UpdateVisualization();
          }

         document.getElementById("myRange").onchange=function(){
           //console.log("change");
           m_experimentres["actions"].push({"id":"myRange","timestamp": Date.now(), "description":"Change hour to "+document.getElementById("myRange").value.toString()});
           let t_hour=parseInt(document.getElementById("myRange").value)+1;
            $("#lmyRange").text("Hour(1-12): "+t_hour);
            SetTargetpolygon();
           UpdateVisualization();
         }

         document.getElementById("myClues").onchange=function(){
           //console.log("change");
           m_experimentres["actions"].push({"id":"myClues","timestamp": Date.now(), "description":"Change hour to "+document.getElementById("myClues").value.toString()});
           let t_clue=parseInt(document.getElementById("myClues").value);
            $("#lmyClues").text("Clue(0-3): "+t_clue);
           UpdateVisualization();
         }

         document.getElementById("sel_ic").onchange=function(){
           ClearAll();
           m_scenario_index=document.getElementById("sel_ic").selectedIndex;
           view.goTo([ m_scenarios[m_scenario_index]['center'] ]);

           m_lpdata_con=[];
           m_lpdata_trial=[];

           m_lpdata_trajectory=[];
           m_lpdata_tra_colormap=[];

           document.getElementById("loadlpmcsv").value="Load LPM Data";
           DisableAllGraphicLayers();

         }

         document.getElementById("sel_colormap").onchange=function(){

             m_experimentres["visualization_type"]=document.getElementById("sel_lpmodel").value;
             m_experimentres["actions"].push({"id":"sel_colormap","timestamp": Date.now(), "description":m_experimentres["visualization_type"]});

             //console.log(m_experimentres);
             DisableAllGraphicLayers();
             UpdateVisualization();
         }
         //--------------------------------------------------
           document.getElementById("lpmmodeldisplay").onclick=function() {
             m_experimentres["actions"].push({"id":"lpmmodeldisplay","timestamp": Date.now(), "description":"diplay model"});
             DisableAllGraphicLayers();
             UpdateVisualization();
           }

           function DisableAllGraphicLayers(){
             visualization_Contourmap_Layer.visible=false;
             visualization_Trajectories_Layer.visible=false;
             visualization_Cone_Layer.visible=false;
             temperalgraphicLayer.visible=false;
             visualization_Segmentheat_Layer.visible=false;
           }

           function UpdateVisualization(){
             //console.log("UpdateVisualization");
             if (document.getElementById("sel_lpmodel").value=="contour"){
               // either 'byhour' or 'byclue'
               //console.log(m_lpdata_con);
               AddLPDataToContourlayer(m_visualizationtype);
             }
             else if(document.getElementById("sel_lpmodel").value=="clueipp"){
               //AddCluetoInteractionImagelayer();
             }
             else if(document.getElementById("sel_lpmodel").value=="cone"){
               //AddCluetoInteractionImagelayer();
               AddLPDataToConelayer();
             }
             else if(document.getElementById("sel_lpmodel").value=="trajectories"){
               //AddCluetoInteractionImagelayer();

               AddLPDataToTrajectorylayer(m_visualizationtype);
             }
             else if(document.getElementById("sel_lpmodel").value=="segmentheat"){
               //AddCluetoInteractionImagelayer();
               AddLPDataToSegmentheatlayer(m_visualizationtype);
             }
           }


          function readDB(gpsdevice,Loadgpsid){

            let sel_gpsdevice = document.getElementById(gpsdevice);

              clearInterval(timerid1);

               if(document.getElementById(Loadgpsid).value=="Load GPS"){
                 document.getElementById(Loadgpsid).value='Stop&Save';
                 all_gpsdata[sel_gpsdevice.selectedIndex]=[];
                 gpspatharray[sel_gpsdevice.selectedIndex]=[];
                 timerid1=setInterval(myTimer, 1000);
               }
               else{
                 document.getElementById(Loadgpsid).value="Load GPS";
                 savewholegpsdatatodb(sel_gpsdevice);
                 return
               }
               function myTimer(e){
                 getGPSDataUpdate(gpsdevice);
                 getGPSDisplayUpdate(m_colorgroup['drone1'],m_colorgroup['line1']);
                 //addGPSPath();

                 //display datetime
                 let d = new Date();
                 let t = d.toLocaleTimeString();
                 document.getElementById("daytime").innerHTML = t;

               }
             }

             function readDB2(gpsdevice,Loadgpsid){

               let sel_gpsdevice = document.getElementById(gpsdevice);

                 clearInterval(timerid2);

                  if(document.getElementById(Loadgpsid).value=="Load GPS"){
                    document.getElementById(Loadgpsid).value='Stop&Save';
                    all_gpsdata[sel_gpsdevice.selectedIndex]=[];
                    gpspatharray[sel_gpsdevice.selectedIndex]=[];
                    timerid2=setInterval(myTimer, 1000);
                  }
                  else{
                    document.getElementById(Loadgpsid).value="Load GPS";
                    savewholegpsdatatodb(sel_gpsdevice);
                    return
                  }
                  function myTimer(e){
                    getGPSDataUpdate(gpsdevice);
                    getGPSDisplayUpdate(m_colorgroup['drone2'],m_colorgroup['line2']);
                    //addGPSPath();

                    //display datetime
                    let d = new Date();
                    let t = d.toLocaleTimeString();
                    document.getElementById("daytime").innerHTML = t;

                  }
            }


          function getDronepathfromDB(id_device_id,pathcolor,lineweight=5){
              let URL = "{% url 'pathplanningupdate' %}";
              let data = {
                      csrfmiddlewaretoken: '{{ csrf_token }}',
                      'id_device_id': id_device_id
                     };
              $.post(URL, data, function(response){
                let res=JSON.parse(response);
                  if(res.flag == 'success'){
                    let arrres=JSON.parse(res.waypointsdata);
                    waypointstartpointarray=[arrres[0].long,arrres[0].lat];
                    UpdateDronePathDisplay(arrres,pathcolor,lineweight,pathplanninggraphicsLayer);
                   }
                  else{ alert(response); }
              });

          }

          function UpdateGPSHistoricalPath(id_device_id,pathcolor,lineweight=5,type='update'){
            clearInterval(timerid3);
            if(type=='update'){
              timerid3=setInterval(myTimer, 1000);
            }
            else{
              //savepathtodb();
              return
            }
            function myTimer(e){
              getDronepathfromDB2(id_device_id,pathcolor,lineweight,gpshistoricalgraphicsLayer);
              let d = new Date();
              let t = d.toLocaleTimeString();
              document.getElementById("daytime").innerHTML = t;
            }
         }

          function getDronepathfromDB2(id_device_id,pathcolor,lineweight,displaylayer){
              let URL = "{% url 'gpshistoricaldataupdate' %}";
              let data = {
                      csrfmiddlewaretoken: '{{ csrf_token }}',
                      'id_device_id': id_device_id
                     };
              $.post(URL, data, function(response){
                let res=JSON.parse(response);
                  if(res.flag == 'success'){
                    let arrres=JSON.parse(res.gpshistoricaldata);
                    //console.log(arrres);
                    gpshistoricalarraystart=[arrres[0].long,arrres[0].lat];
                    UpdateDronePathDisplay(arrres,pathcolor,lineweight,displaylayer);
                   }
                  else{ alert(response); }
              });

          }

          function UpdateDronePathDisplay(pt_arr,pathcolor,lineweight,displayLayer){
            //update the drone path on pathplanninglayer

            displayLayer.removeAll();
            let path_featureset=[];
            let path_polyline=[];
            //draw all gpsdata
            //console.log(arrinput);
            //let pt_arr=arrinput;
            for(let i=0;i<pt_arr.length;i++){
              let t_graphic= new Graphic({
                geometry: {
                  type:'point',
                  latitude:pt_arr[i].lat,
                  longitude:pt_arr[i].long,
                  spatialReference:view.spatialReference
                },
                symbol:  {
                  type: "simple-marker",
                  style:"circle",
                  color: pathcolor,
                  size:12
                  }
              });
              path_featureset.push(t_graphic);

              let t_graphic_text=new Graphic ({
                geometry:{
                  type:'point',
                  latitude:pt_arr[i].lat,
                  longitude:pt_arr[i].long,
                  spatialReference:view.spatialReference
                },
                symbol:{
                  type: "text",  // autocasts as new TextSymbol()
                  color: "white",
                  haloColor: "black",
                  haloSize: "1px",
                  text: pt_arr[i].stamp,
                  xoffset: 0,
                  yoffset: 0,
                  font: {  // autocast as new Font()
                    size: 10,
                    family: "sans-serif",
                    weight: "bold"
                  }
                }
              });
              path_featureset.push(t_graphic_text);
              path_polyline.push([pt_arr[i].long,pt_arr[i].lat]);
            }
            //waypointstartpointarray=path_polyline[0];
            //console.log(path_featureset);
            let polylineGraphic = new Graphic({
              geometry: {
                type: "polyline",
                paths: path_polyline
              },
              symbol: {
                type: "simple-line",
                color: pathcolor,
                width: lineweight
              }
            });
            displayLayer.visible=true;
            displayLayer.add(polylineGraphic);
            displayLayer.addMany(path_featureset);
          }

           function savewholegpsdatatodb(sel_gpsdevice){

               let URL = "{% url 'gpsdatastorage' %}";
               let rand_gpsdevicename = Date.now().toString();
               let id_device_id = sel_gpsdevice.options[sel_gpsdevice.selectedIndex].text;
               // let device_id = sel_gpsdevice.options[sel_gpsdevice.selectedIndex].text;
               let taskid = document.getElementById("tasknotes").value;
               let str_all_gpsdata= JSON.stringify(all_gpsdata[sel_gpsdevice.selectedIndex]);
               let data = {
                       csrfmiddlewaretoken: '{{ csrf_token }}',
                       'task_notes': taskid,
                       'rand_gpsdevicename':rand_gpsdevicename,
                       'id_device_id': id_device_id,
                       'device_id': id_device_id,
                       'all_gpsdata' : str_all_gpsdata
                       //'all_gpsdata' : all_gpsdata[sel_gpsdevice.selectedIndex].toString()
                      };
               $.post(URL, data, function(response){
                 let res=JSON.parse(response);
                   if(res.flag == 'success'){
                     //console.log(res.gpsdata);
                    }
                   else{ alert(response); }
               });

               //download gps data as csv file
               //let filename=taskid+"_"+id_device_id+"_"+rand_gpsdevicename+".txt";
               //download(filename, str_all_gpsdata);
           }

         function getGPSDataUpdate(gpsdevice){
           let sel_gpsdevice = document.getElementById(gpsdevice);
           //console.log(document.getElementById("sel_gpsdevice").value);
           let id_device_id = sel_gpsdevice.options[sel_gpsdevice.selectedIndex].text;
             let URL = "{% url 'gpsupdate' %}";
             let data = {
                     csrfmiddlewaretoken: '{{ csrf_token }}',
                     'id_device_id': id_device_id
                    };
             $.post(URL, data, function(response){
               let res=JSON.parse(response);
                 if(res.flag == 'success'){
                   //console.log(res.gpsdata);
                   t_obj=JSON.parse(res.gpsdata);
                   let gps_json;

                   if ("gps" in t_obj){
                     gps_json=t_obj.gps[0];
                   }
                   else{
                     gps_json=t_obj;
                   }
                   gps_json.time=Date.now();
                    //console.log(t_obj);
                    gpspatharray[sel_gpsdevice.selectedIndex].push([gps_json.long,gps_json.lat]);
                    all_gpsdata[sel_gpsdevice.selectedIndex].push([gps_json.stamp,gps_json.time,gps_json.long,gps_json.lat]);

                    //all_gpsdata_timestamp[sel_gpsdevice.selectedIndex].push();
                  }
                 else{ alert(response); }
             });
         }


         document.getElementById('GPSStart').addEventListener('click',function(){
           readDB("sel_gpsdevice","GPSStart");
         });
         document.getElementById('GPSStart2').addEventListener('click',function(){
           readDB2("sel_gpsdevice2","GPSStart2");
         });

         document.getElementById('loaddronepath').addEventListener('click',function(){
           if(document.getElementById('loaddronepath').value=="Show Path"){
             document.getElementById('loaddronepath').value='Hide Path';

             let sel_gpsdevice = document.getElementById("sel_dronepath");
             let id_device_id = sel_gpsdevice.options[sel_gpsdevice.selectedIndex].text;
             getDronepathfromDB(id_device_id,m_colorgroup['path1']);

           }
           else{
             document.getElementById('loaddronepath').value='Show Path';
             //hide path
             pathplanninggraphicsLayer.visible=false;
           }

         });

         document.getElementById('loadhistoricaldronepath').addEventListener('click',function(){
           let sel_gpsdevice = document.getElementById("sel_historicaldronepath");
           let id_device_id = sel_gpsdevice.options[sel_gpsdevice.selectedIndex].text;
           if(document.getElementById('loadhistoricaldronepath').value=="Load Path"){
             document.getElementById('loadhistoricaldronepath').value='    Stop   ';
             UpdateGPSHistoricalPath(id_device_id,m_colorgroup['path2'],3,type='update')
           }
           else{
             document.getElementById('loadhistoricaldronepath').value='Load Path';
             //hide path
             UpdateGPSHistoricalPath(id_device_id,m_colorgroup['path2'],3,type='stop')
           }

         });


         document.getElementById('visualizationtype').addEventListener('click',function(){
           if(document.getElementById("visualizationtype").checked){
                 m_visualizationtype='byclue';
               }
               else{
                 m_visualizationtype='byhour';
               }
         });
      //--------------------------------------------------

      var m_conditions=bobdata.bob160;
      let gc_longitude=m_scenarios[m_scenario_index]['center'][0];
      let gc_latitude=m_scenarios[m_scenario_index]['center'][1];
      //DrawAllPoints();

      function DrawAllPoints(){
        graphicfilterLayer.removeAll();
        let t_feature=[];

        for(let i=0;i<158;i++){
          //console.log(i);
          let in_symbol=getSymbol(m_conditions[i].subject);
          let t_pt=GetPoints(i,in_symbol)
          //console.log(t_pt);
          t_feature.push(t_pt);
        }

         graphicfilterLayer.addMany(t_feature);
      }
      function getSymbol(keywords){
        let res={
          type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
          style:"triangle",
          color: [255,255,0],
          size: 10
        };
        let symbol_hiker={
             type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
             style:"circle",
             color: [255,0,0],
             size: 10
           };
        let symbol_child={
                type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                style:"circle",
                color: [0,255,0],
                size: 10
              };
        let symbol_others={
                type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                style:"circle",
                color: [0,0,255],
                size: 10
              };
        if(keywords.includes("Child")){
          res=symbol_child
        }
        else if(keywords.includes("Hiker")){
          res=symbol_hiker
        }
        else if(keywords.includes("Dementia")){
          res=symbol_others
        }
        return res;
      }

      function GetInitPoint(t_longitude,t_latitude,in_symbol){
        let in_point=new Point({
          longitude:t_longitude,
          latitude:t_latitude,
          spatialReference:view.spatialReference
        });

        let t_graphic =  new Graphic({
          geometry: in_point,
          symbol:  in_symbol,
           attributes:{
             Name:"findlocation"
           },
           popupTemplate:{
              title: "init point",
              content: "init point"}

        });
        return t_graphic;
      }

      function generatehtml(obj,inobj=null){
        let res="<ul> ";
        Object.keys(obj).forEach(function(key,index) {
            // key: the name of the object key
            // index: the ordinal position of the key within the object
            res=res+"<li>"+key+":"+obj[key].toString()+"</li>";
        });
        //console.log(inobj);
        if(inobj){
          Object.keys(inobj).forEach(function(key,index) {
              res=res+"<li>"+key+":"+inobj[key].toString()+"</li>";
          });
        }

        res=res+"</ul>";
        return res;
        //for (const item in obj){  }
      }
      function MeasureDistance(lat1, lon1, lat2, lon2){  // generally used geo measurement function
        var R = 6378.137; // Radius of earth in KM
        var dLat = lat2 * Math.PI / 180 - lat1 * Math.PI / 180;
        var dLon = lon2 * Math.PI / 180 - lon1 * Math.PI / 180;
        var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var d = R * c;
        return d * 1000; // meters
      }


      function GetPoints(in_index=0,in_symbol={}){

        //translate m_location
        let t_longitude=gc_longitude-m_conditions[in_index].distanceew;
        let t_latitude=gc_latitude-m_conditions[in_index].distancens;
        let in_point=new Point({
          longitude:t_longitude,
          latitude:t_latitude,
          spatialReference:view.spatialReference
        });

        let resdistancemeter=MeasureDistance(m_conditions[in_index].lpp[0],
          m_conditions[in_index].lpp[1],
          m_conditions[in_index].findcoord[0],
          m_conditions[in_index].findcoord[1]
          );
        let in_obj={"distance(meter)":resdistancemeter};
        let t_graphic =  new Graphic({
          geometry: in_point,
          symbol:  in_symbol,
           attributes:{
             Name:"findlocation"
           },
           popupTemplate:{
              title: m_conditions[in_index].subject,
              content: generatehtml(m_conditions[in_index],in_obj)
            }

        });
        return t_graphic;
      }
    });


  </script>
</head>

<body>


  <div id="editArea" class="editArea-container">
    <h2 class="list-heading">Search & Rescue Tools</h2>
    <div>
      <h3 class="list-heading">Map Division</h3>
      <div>
        <label >Load a scene: </label>
        <select id="sel_ic">
          <option value="0">Scene 1</option>
          <option value="1">Scene 2</option>
          <option value="2">Scene 3</option>
        </select>
        <input type="button" id="label_ic" value="Load" style="display:none"></input>
      </div>

      <div>
        <label >Lost person type: </label>
        <select id="sel_lpm">
          <option value="child10to12">Child</option>
          <option value="dementia">Dementia</option>
          <option value="hiker" selected>Hiker</option>

        </select>
        <input type="button" id="label_lpt" value="Switch" style="display:none"></input>
      </div>

      <div>
        <input type="button" class="edit-button" value="Load LPM Data" id="loadlpmcsv">
      </div>

      <!--div><input type="checkbox" name="voronoi" class="check" value="random"> Random Voronoi</input></div-->
      <!--div><input type="checkbox" name="voronoi" class="check" value="triangle"> Triangle based on vertices</input></div-->
      <!--div><input type="checkbox" name="voronoi" class="check" value="clear"> Freehand Polygon</input></div-->

      <input type="button" class="edit-button" value="Generate task" id="btngeneratearea"/>
      <input type="button" class="edit-button" value="Edit cells" id="btneditcells" style="display:none"/>

      <div  style="display:none">
        <input type="text" class="bt_save_edit" id="tasknotes" value="Task_name"></input>
        <input type="button" class="bt_save" value="Save Task" id="savetasks"></input>
      </div>
    </div>

    <hr/>
    <div>
      <h3>Lost person model</h3>

      <div>


      <div>
        <label id="colormap">Color map: </label>
        <select id="sel_colormap" class="sel_options">
          <option value="o_rainbow">Rainbow</option>
          <option value="o_yr">Yellow-red</option>
          <option value="o_br">Blue-red</option>
        </select>
        <input type="button" id="colormap" value="Switch" style="display:none"></input>

      </div>

      <div>
        <label >Model best fit: </label>
        <select id="sel_rank">
          <option value="1">bf1</option>
          <option value="2">bf2</option>
          <option value="3">bf3</option>
        </select>
        <input type="button" id="label_rank" value="Switch" style="display:none"></input>
      </div>

      <div class="slidecontainer">
        <label for="myRange" id="lmyRange">Hour(1-12): 1</label>
        <input type="range" min="0" max="11" value="0" class="slider" id="myRange">

      </div>
      <div class="slidecontainer">
        <label for="myClues" id="lmyClue">Clue(0-3): 0</label>
        <input type="range" min="0" max="3" value="0" class="slider" id="myClues">
      </div>

      <div>
        <select id="sel_lpmodel">
          <option value="clueipp">IPP & Rings</option>
          <option value="contour">Contour map</option>
          <option value="trajectories">Trajectories</option>
          <option value="cone">Cone</option>
          <option value="segmentheat">Segment heat</option>
        </select>
        <input type="button" id="lpmmodeldisplay" value="Display" disabled></input>
        <input type="checkbox" id="displaytype" name="displaytype" value="byhour">
        <label for="displaytype">Groupbyhr</label>
      </div>
    </div>
  </div>

    <div>
      <hr/>
      <h3>Task Assignment</h3>
      <div>
        <table>
          <thead>
            <tr>
              <th>Team</th>
              <th>1</th>
              <th>2</th>
              <th>3</th>
              <th>4</th>
              <th>5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>Cell</th>
              <th id="th_team1">SX</th>
              <th id="th_team2">SX</th>
              <th id="th_team3">SX</th>
              <th id="th_team4">SX</th>
              <th id="th_team5">SX</th>
            </tr>
          </tbocy>
        </table>
        <input type="button"  class="edit-button" id="btntaskassignment" value="Assign"></input>
      </div>
    </div>

    <hr>
    <div id="draw" style="display:none">
      <h3 class="list-heading">Map measurement tools</h3>
      <div><input type="button" class="edit-button" value="Measure distance" id="distanceButton"></input></div>
      <div><input type="button" class="edit-button" value="Measure area" id="areaButton"></input></div>
    </div>
    <div style="display:none">
      <input type="button" class="edit-button" value="Display Lost Person Info" id="lpinfo">

    </div>
    <input type="checkbox" id="visualizationtype" name="visualizationtype" value="byhour">
    <label for="visualizationtype">Filter data by clue(none,1,2,12)</label>

    <input type="button"  class="edit-button" id="btndisplaytarget" value="Show Target"></input>

    <div><input type="button" class="edit-button" value="Clear All" id="clearall"></input></div>

    <hr/>
    <div>
      <h3>Path Planning</h3>
      <div>
        <select id="sel_dronepath">
          <option value="">Select a device</option>
          {% for device in dronepath %}
          <option value="{{ device.id }}">{{ device.deviceid }}</option>
          {% endfor %}
        </select>
        <input type="button" id="loaddronepath"  value="Show Path"></input>
        <input type="button" id="gotoGPSLocation3"  value="Locate"></input>
      </div>
    </div>

    <hr/>
    <div>
      <h3>Drone status</h3>
        <div>
          <select id="sel_gpsdevice">
            <option value="">Select a device</option>
            {% for device in gpsdevice %}
            <option value="{{ device.id }}">{{ device.deviceid }}</option>
            {% endfor %}
          </select>
          <input type="button" id="GPSStart"  value="Load GPS"></input>
          <input type="button" id="gotoGPSLocation"  value="Locate"></input>
        </div>
        <div>
          <select id="sel_gpsdevice2">
            <option value="">Select a device</option>
            {% for device in gpsdevice %}
            <option value="{{ device.id }}">{{ device.deviceid }}</option>
            {% endfor %}
          </select>
          <input type="button" id="GPSStart2"  value="Load GPS"></input>
          <input type="button" id="gotoGPSLocation2"  value="Locate"></input>
        </div>

    </div>
    <div>
      <h3>Drone path</h3>
      <div>
        <select id="sel_historicaldronepath">
          <option value="">Select a device</option>
          {% for device in dronehistoricalpath %}
          <option value="{{ device.id }}">{{ device.deviceid }}</option>
          {% endfor %}
        </select>
        <input type="button" id="loadhistoricaldronepath"  value="Load Path"></input>
        <input type="button" id="gotoGPSLocation4"  value="Locate"></input>
      </div>

    </div>
    <p id="daytime"></p>
  </div>



  <div id="viewDiv">
    <div id="sidebar" class="esri-widget" style="display:none">
    </div>
  </div>
</body>
</html>
